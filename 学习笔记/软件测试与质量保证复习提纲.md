# 软件测试与质量保证复习提纲

## 第一章 Introduction

- 为什么我们需要软件测试？
  - 我们需要软件
  - 我们需要质量好的软件
  - 我们需要一些方法来确保质量

- 质量被定义作为一个软件的卓越程度
- 质量能被解释作为满足接连着的消费者需求
  - 易于理解的
    - 外部的：功能，可用性
  - 不易于理解的
    - 内部的：稳定性，用户体验

- 为了在软件开发过程中确保软件质量，你需要在软件开发生命周期的每个阶段实现软件质量确保

- 软件质量保证是一个有计划的、系统的方法来监测和优化软件开发过程
- 软件质量保证过程评估软件产品和软件产品标准的粘合度

- 为了确保质量保证实体被满足，一个项目软件质量保证计划被创造了
  - 综合性项目计划的一部分
  - 明确规定了质量保证的程序
  - 分配角色和职责
- 计划-做-检查-执行

- 质量活动可以被分为两个分类
  - 预防活动
  - 监测活动
- 质量保证侧重于预防缺陷而不是监测缺陷并是用来实现定义好的质量政策通过不断地发展和优化地过程

- 质量保证活动包括：
  - 质量监听
  - 过程定义
  - 工具选择
  - 训练
  - 同行检查
  - 需求追踪
  - 质量度量收集
- 质量控制是一个过程，这个过程中一个产品被很多特定标准对比，并且行动会被采取如果质量没有和应用标准所匹配
- 质量控制更偏向于监测错误而不是预防
- 质量控制活动包括：
  - 检查
  - 测试
  - 检查点检查
- QA VS. QC
- What is testing?
- Who does testing?
- When to Start testing?
- When to Stop testing?
- 5W+1H

#### 测试的定义

测试是一个分析软件去监测存在和被需要的状况之间的区别的过程，并去评估软件实体的功能

测试无处不在

- 谁去测试
  - 软件测试人员
  - 软件开发人员
  - 项目领导/经理
  - 终端用户
- 什么时候开始测试
  - 越早越好
  - 依赖于开发模型
  - 测试在开发的每个阶段以不同的形式被完成
- 什么时候结束测试？
  - 测试是一个永不结束的过程
  - 一些方面
    - 测试截止日期
    - 管理决定
    - 测试用例执行的完成
    - 功能和代码覆盖完成到了某个程度
    - Bug率跌落到一个确定的水平并且没有高优先级的bug被发现

## 第二章 Preliminary to Software Testing

#### What is "defect"

- Error：发生在写一个程序的过程中
- Fault：是一个和多个错误的集合
- Failure：发生在错误代码被执行得到了一个预期之外错误的输出时
- Incident：没有信息被展示当失效发生时

#### Software defect definition

- 所有软件问题
- 存在于代码数据和文档中
- 和用户期望不一致

#### Defect example：

- 软件功能不能被正确执行
- 缺点
  - 运行太慢
- 不一致性
  - Ctrl+S不能保存所有应用

- 用户接口设计错误
  - 一个按钮应该展示5个文字在上面，但是只能看到3个文字

#### Verification

- 软件应该和它的规格说明保持一致

#### Validation

- 软件应该做用户真的需要它做的事情

#### Test Information Flow

![image-20210107144351947](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107144351947.png)

#### Testing Life Cycle

![image-20210107144454468](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107144454468.png)

#### The  V model

![image-20210107144545720](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107144545720.png)

#### The W model

![image-20210107144627791](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107144627791.png)

#### 软件测试方法

- 白盒测试
- 黑盒测试
- ![image-20210107144743787](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107144743787.png)

## 第三章 Logic Coverage

#### 为什么我们不能使用全面测试？

- 时间耗费太多了
- 路径全面测试不能监测到所有错误因为路径遗漏
- 路径全面测试不能发现和数据有联系的错误

#### Logic coverage

- Statement Coverage
- Decision Coverage
- Condition Coverage
- Condition-Decision Coverage
- Condition Combination Coverage
- Path Coverage
- Complete Coverage
- Modified Condition/Decision Coverage

#### Statement Coverage

![image-20210107151634687](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107151634687.png)

![image-20210107151642561](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107151642561.png)

#### Decision coverage

![image-20210107151713395](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107151713395.png)

#### Condition coverage

![image-20210107151832187](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107151832187.png)

#### Condition/Decision Coverage

![image-20210107151915290](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107151915290.png)

#### Condition Combination Coverage

![image-20210107151951906](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107151951906.png)

![image-20210107152002845](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107152002845.png)

#### Path Coverage

![image-20210107152033009](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107152033009.png)

#### Complete Coverage

![image-20210107152059529](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107152059529.png)

#### MC/DC

- A code coverage criterion that requires:
  - Each entry and exit point is invoked
  - Each decision takes every possible outcome
  - Each condition in a decision takes every possible outcome
  - Each condition in a decision is shown to independently affect the outcome of the decision

## 第四章 Basis Path Testing

#### Cyclomatic Complexity

![image-20210107152536194](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107152536194.png)

![image-20210107152556950](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107152556950.png)

![image-20210107152609498](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107152609498.png)

![image-20210107152647494](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107152647494.png)

![image-20210107152658520](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107152658520.png)

![image-20210107152716460](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107152716460.png)

![image-20210107152727356](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107152727356.png)

### 第5章 循环测试

自我总结：循环测试属于白盒测试的一种，但是期中复习的时候可以说是没有怎么特别搞清楚，所以期末要重点看看，不知道老师会不会考。

#### Z-path coverage

![image-20201230011125165](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230011125165.png)

提示：要结合实际，不要死脑筋。注意路径2的判断

#### data flow testing

- 不正确的任务或者输入语句
- 定义缺失
- 断言错误

变量被定义的三种情况

- Y：=17
- input（Y）
- DOIT（X:IN,Y:OUT）

9种d、u、k的组合

dd-不是不合法的，但是是令人怀疑的。很可能是编码错误

du-完美正确。正常的情况

dk-不是不合法的，但是很可能是一个编码错误

ud-可以接受的

uu-可以接受的

uk-可以接受的

kd-可以接受的

ku-一个严重的错误

kk-很可能是一个编码错误

#### data flow graph

![image-20201230103515666](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230103515666.png)

#### Loop Testing 

- 简单循环
- 筑巢型循环
- 连接循环
- 结构凌乱的循环

#### 继续 data flow testing

##### definition clear(def-clear)

如果没有re-definition of v within the path

##### definition-use pair(du-pair)

### 第七章 黑盒测试——Boundary Value Analysis

为什么我们需要黑盒测试

- 总体上看，对程序内代码的特定的知识是不需要的
- 测试者只知道合法的输入和应该的输出
- 测试人员知道这个软件应该做什么但不知道它是怎么做到这个的

黑盒测试是很难找到错误发生的原因的

黑盒测试的方法

- Boundary Value Analysis
- Equivalence Partitioning
- Decision Table
- Cause-Effect Graph
- Combinatorial Test

边界测试的思想：

如果你可以安全的通过悬崖的边界，那么你几乎不用担心你可以安全的行走在悬崖中

errors tend to occur near the extreme
values of an input variable

基本想法：

- min
- min+
- nom
- max-
- max

#### Robustness Testing

鲁棒测试

主要就是针对比最大大一点和比最小小一点

边界值分析包含四种技术

- Normal Boundary Values
- Robustness Boundary Values
- Multiple Variable of Boundary Values（Worst-Case Testing）
- Robust Multiple Variable of Boundary Values（Robust Worst-Case Testing）

例子2

如果有两个变量x,y

- $a<=x<=b$
- $c<=y<=d$

至少有多少测试用例需要被创造？

![image-20201230111340669](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230111340669.png)

![image-20201230111408938](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230111408938.png)

![image-20201230111422203](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230111422203.png)

- Multiple Variable of Boundary Values

![image-20201230111504570](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230111504570.png)

- Robust Multiple Variable of Boundary Values

边界值分析的局限性：边界值会对测试对象有重要影响的效果才好，比如说如果是测试数字密码，这样的边界值就没有什么意义。

### 第八章 黑盒测试——Equivalence Partitioning

Equivalence Class

- 不能有交集
- 要覆盖整个选择区域

测试步骤：

- 把整个测试数据的范围划分为几个等价类
- 这些等价类的划分标准是更可能能得到同一结果的类
- 每个等价类中选取一个作为测试样例

![image-20201230120014592](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230120014592.png)

注意细节：a和b都少了0，所以不是正确的等价类划分

![image-20201230120327088](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230120327088.png)

![image-20201230120405621](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230120405621.png)

例子中的等价类划分可以看出来还是比较简单的

![image-20201230215236760](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230215236760.png)

![image-20201230215417121](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230215417121.png)

![image-20201230215510670](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230215510670.png)

![image-20201230215635789](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230215635789.png)

![image-20201230215931897](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230215931897.png)

#### What is the number of test cases for

- Weak Normal Equivalence Class Testing
- Strong Normal Equivalence Class Testing
- Weak Robust Equivalence Class Testing
- Strong Robust Equivalence Class Testing
- Hybrid approach

#### Given $x_1$,$x_2$,$x_3$,...,$x_n$; valid ECs E($x_1$),E($x_2$),E($x_3$),...,E($x_n$); invalid ECs I($x_1$),I($x_2$),...,I($x_n$):

– Weak Normal Equivalence Class Testing
• Max{E($x_1$), E($x_2$), …, E($x_n$)}

– Strong Normal Equivalence Class Testing
• E($x_1$)* E($x_2$)*…*E($x_n$)

– Weak Robust Equivalence Class Testing
• Max{E($x_1$), E($x_2$), …, E($x_n$)}+$\sum_{i=1}^nI(x_i)$ 

– Strong Robust Equivalence Class Testing

•$\prod_{i=1}^n(E(x_i)+I(x_i))$

– Hybrid approach
• E($x_1$)* E($x_2$)*…*E($x_n$)+$\sum_{i=1}^nI(x_i)$

#### 等价类划分法和边界值分析法的不同

- 等价类划分法:将测试过程中的输入、输出、操作等相似内容分组，从每组中挑选具有代表性的内容作为测试用例，划分有效等价类和无效等价类
- 边界值分析法：确认输入、输出的边界，然后取刚好等于、大于、小于边界的参数作为测试用例测试；
- 联系：等价类划分和边界值要一起考虑，边界值分析法属于等价类划分法的补充，任何等价区间都有边界，有边界就有等价区间

### 黑盒测试——Decision Table

- Decision table is good for representing and analyzing complex logical relationships.

#### decision table

- 限制进入条件选择表：所有的状态都是双选
- 扩展进入条件选择表：条件允许有几个值
- 混合进入条件选择表

![image-20201230224840189](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230224840189.png)

![image-20201230224954961](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230224954961.png)

![image-20201230225020788](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230225020788.png)

#### How to make a decision table?

1、列出条件选项和行为选项

2、填满条件的选项

3、填满行为选项，做一个初始表

4、决定表检验

#### Decision Table Verification

- Completeness
  - For limited entry decision tables, if n conditions exist, there must be 2 n rules.
- Combining
- Redundancy
- Inconsistence

#### 在决定表中组合规则

![image-20201230230758996](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230230758996.png)

可以把action相同的一些表的列进行合并

![image-20201230231316390](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230231316390.png)

以上是一个事例

#### 三角形问题的决定表

![image-20201230231416139](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230231416139.png)

可以把它变得更具体

![image-20201230231515893](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230231515893.png)

#### BVA VS EP VS DT

- 边界值分析
  - 基于取值域，不识别数据或逻辑关系
  - 很容易自动化实现，设计工作量小
  - 生成的测试用例数比较多，测试用例执行时间长

- 等价类技术
  - 考虑数据依赖关系，标识等价类时需要更多的判断和技巧
  - 等价类标识出以后的处理也是机械的
  - 设计工作量和测试用例数属中等

- 决策表技术
  - 考虑数据的逻辑依赖关系
  - 所得测试用例可以是完备的，测试数量在一定意义上讲是最少的
  - 需要通过多次迭代，设计工作量很大

### Cause-Effect Graph

##### 特点:

The Cause-Effect Graphing technique begins with the set of requirements, and determines the minimum number of test cases to completely cover the requirements.

#### 定义：

- Causes /effects are represented as nodes in the cause-effect graph
- The graph also includes a number of intermediate nodes linking causes and effects

#### Cause-Effect Graph 的部件

![image-20201230234053726](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230234053726.png)

#### 图的一些限制条件

![image-20201230234204522](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230234204522.png)

![image-20201230234324023](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20201230234324023.png)

限制的说明

#### 画Cause-Effect Graph的步骤

1、 Identify causes and effects in specification

2、 Make Boolean graph linking causes and
effects.

3、Annotate impossible combinations of causes
and effects (adding constraints)

4、Develop decision table from graph

5、Transform each column into test case

### 黑盒测试——Combinatorial Test

#### 任何解决组合爆炸问题？

- 组合测试：抽样，优化组合
  - 将被测试应用抽象为一个受到多个因素影响的系统，其中每个因素的取值是离散且有限的
  - 正交实验设计
  - 多因素（N-way，N>2）组合测试可以覆盖任意N个因素的所有取值组合，在理论上可以发现由N个因素共同作用引发的缺陷

#### 正交实验设计

- 从大量的数据（测试例）中挑选适量的、有代表性的点（例）,从而合理地安排实验（测试）的一种科学实验设计方法 

- 采用正交设计法设计测试用例主要包括以下步骤：
  - 确定影响因素
  - 确定每个因素的水平
  - 选择正交表
    - 根据确定的因素和水平，选择合适的正交表
    - 如果没有合适的正交表可用或需要的测试用例个数太多，则要对因素和水平进行调整

- 设计测试用例

#### 正交表

一个例子

![image-20210103173425361](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103173425361.png)

示例2

![image-20210103173516086](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103173516086.png)

- 全面实验法
  - 优点：对各因子与指标间的关系剖析得比较清楚
  - 缺点：实验次数太多

- 简单对比法
  - 首先固定B、C于B1、C1，使A变化
  - B1C1——A1
  - ​         ——A2
  - ​         ——A3（好结果）
  - 若结果A3最好，则固定A于A3，C还是C1，使B变化
  - 依次下去对比
  - 试验次数少，但选择代表性差

- 用正交实验设计法所需的行数是多少？
  - 最少试验次数（行数）=求和【各个列数*（水平-1）】+1
  - 示例1，示例2   --相同水平正交表$L_9(3^4)$
  - 示例3：--混合正交表
    - 五个3水平因子及一个2水平因子，则试验次数至少为$5*(3-1)+1*(2-1)+1=12$
    - 可以选择$L18(2*3^7)$的正交表

#### 正交表

- 何为正交表？
  - 任意t个输入变量间
  - 每个t元输入取值组合排列方式齐全而且均衡（出现次数）

- 优势：对组合的覆盖 空间分布均匀
- 劣势：正交表构造困难 难以判定存在性

又是一个例子

![image-20210103180812190](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103180812190.png)

#### 组合覆盖表

- 何为组合覆盖表
  - 任意t个输入变量间
  - 每个t元输入取值组合出现至少一次

- 优势：
  - 覆盖表必然存在
  - 覆盖表便于构造

下面我们举一个例子

![image-20210103181026457](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103181026457.png)

第一种情况 强度t=2，出现次数$\lambda$不相等

![image-20210103182307996](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103182307996.png)

第二种情况 强度t=3

![image-20210103182420573](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103182420573.png)

### 组合测试

- 两因素组合测试（也称配对测试、全对偶测试）
  - 测试集可以覆盖任意两个变量的所有取值组合。在理论上，可以暴露所有由两个变量共同作用而引发的缺陷

- 多因素（t-way，t>2）
  - 测试集可以覆盖任意t个变量的所有取值组合。在理论上，可以发现所有t个因素共同作用引发的缺陷。

- 基于选择的覆盖
  - 选出一个基础的组合，且基础组合中包含每个参数的基础值，建议选择最常用的有效值作为基础值
  - 基于基础组合，每次只改变一个参数值，来生成新的组合用例

#### Pair-wise

- 成对组合，又称两两组合、对对组合，它是将所有因素的水平按照两两组合的原则而产生的
- Mandl于1985年在测试Ada编译程序时提出的

- Pairwise基于如下2个假设：
  - 每一个纬度都是正交的，即每一个维度互相都没有交集
  - 根据数学统计分析，73%的缺陷（单因子是35%，双因子是38%）是由单因子或2个因子相互作用产生的。19%的缺陷是由3个因子相互作用产生的

### 示例

- 假设有三个维度，每个维度有几个因子。如下：
  - 浏览器：M，O，P
  - 操作平台：W(windows)，L(linux)，i(ios)
  - 语言：C(Chinese)，E(English)

- 使用pairwise算法，有多少个测试case？具体是什么case？

- 全覆盖需要$3*3*2=18$个测试case

- ![image-20210103184406420](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103184406420.png)

![image-20210103185817350](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103185817350.png)

从1号开始优化，最终剩下?

![image-20210103185837450](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103185837450.png)

### 组合测试中的一些问题

- 默认取值问题
- 约束问题

### Base Choice

- 基于选择的覆盖
  - 选出一个基础的组合，且基础组合中包含每个参数的基础值，建议选择最常用的有效值作为基础值
  - 基于基础组合，每次只改变一个参数值，来生成新的组合用例

![image-20210103190136716](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103190136716.png)

![image-20210103190147409](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103190147409.png)

![image-20210103190231847](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103190231847.png)

如果有两个默认变量，那么就画两张表

比如下面这个例子

![image-20210103190606754](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103190606754.png)

它可以得到下面两个测试用例表

![image-20210103190630271](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103190630271.png)

### 组合测试中的约束问题

1、强制约束：取值组合为非法

2、非强制约束：取值组合无需覆盖

#### 如何处理强制约束问题？

- 合并输入变量
  - ![image-20210103190858589](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103190858589.png)

- 重构输入区域
  - ![image-20210103190926306](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103190926306.png)

- 修改测试用例
  - ![image-20210103190955025](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103190955025.png)

### Pairwise小结

- Pairwise VS. 单因素
  - Pairwise能够覆盖到两个维度的组合，能适当减少遗漏的测试

- Pairwise VS. 全覆盖设计法 VS. 正交表法
  - 全覆盖设计法测试case太多，投入的成本太大
  - 正交表法是对组合的等概率覆盖，构造困难
  - Pairwise较之全覆盖设计法，减少了测试用例。较之正交表法，构造相对简单，提高了测试效率

## 第12章 Performing Tests

- Unit testing
- Integration testing
- System testing
- Acceptance testing
- Regression testing

- 大部分开发团队采用这样的增量策略进行测试
  - 单元测试
    - 对独立的软件单元进行验证

- - 集成测试
    - 对于不同的软件单元之间的交互进行验证

- - 系统测试
    - 对于整个系统的表现进行验证

- 用户：接受测试

### 单元测试

![image-20210103193021814](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103193021814.png)

#### 为什么我们需要单元测试（why）

- 在开发的过程当中，每1000行代码都会产生很多错误
- 再编译后还会有大概2-6个bug存在于1000行代码中
- 测试和修复bug的开销大概占据开发的30%-60%
- 越早发现错误越好

#### 什么是单元测试？（What）

- 单元测试是一个软件开发过程中最小的测试单元，这可以是一个应用，一个调用单元，它们被单独和分别的检查是否正确的运行

- 一个单元可以是一个程序，一个功能，一个方法之类

##### 单元测试的目的

- 发现编码过程当中的错误
- 检查代码是否和设计一致
- 跟踪需求和设计的实现
- 发现设计和需求中的错误

#### 怎么做单元测试（How）

- Static testing
  - 主要是语法检查代码以及手工地检查代码和文档来发现错误
  - 这种检查能被开发者使用谁写了这个代码，单独的
  - 同行评审，走查和审查也被使用

- Dynamic testing
  - 设计和执行测试用例
  - 工具：Junit，C++ Test，unittest(PyUnit)，Pytest...

### Peer reviews(同行评审)

![image-20210103200959522](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103200959522.png)

#### Walkthroughs(走查)

定义：采用讲解、讨论和模拟运行的方式进行的查找错误的活动

![image-20210103201202255](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103201202255.png)

#### Inspections(审查)

![image-20210103201243467](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103201243467.png)

- 两种方式的对比

![image-20210103201417659](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103201417659.png)

#### 单元测试环境

![image-20210103202146441](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103202146441.png)

#### 单元测试常用工具简介

![image-20210103202630251](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103202630251.png)

### Integration Testing

- Integration testing（集成测试）
  - 这个测试是把单独的软件模块集合分组测试
  - 集成测试主要集中于测试一起工作的多个部件

#### Integration Testing Strategy

- 描述模块集成方式
- 如何去联合系统中的模块？同时被集合还是逐渐被集合
  - 不增量集成策略——in one go
  - 增量集成策略——逐渐实现

- 基于分解的集成
  - Big bang(大爆炸) integration
  - Top-down(自顶向下) integration
  - Bottom-up(自底向上) integration
  - Sandwich(三明治) integration

#### Big Bang integration

- 说明：这是一个不增量的集成方法，它集成所有系统元素在同一个时间，不考虑元素之间的依赖和可能的风险

- 策略：

  ![image-20210103204003316](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103204003316.png)

- 先对每一个子模块进行测试（单元测试阶段）
- 然后将所有模块一次性的全部集成起来进行集成测试

优点：

- 集成测试可以非常快速的完成
- 并且只需要很少的drivers和stubs

缺点：

- 定位和修复bug会变得更加困难如果错误被找到了
- 很多接口的错误不会被发现直到系统测试

使用的地方：

- 已经存在的系统只有很少的改动
- 具有足够多单元测试后的小系统
- 系统由高质量的可复用的标准模块组成

#### Top-down integration

特点：

- 主要关注高级的几个模块，之后逐渐测试底部的模块
- 深度优先策略和宽度优先策略可以被使用
- 实施退化测试，排除因为集成可能导致的错误

- 所有的模块会被集成成系统之后结束测试，不然的话，返回到第二步

策略:

- ![image-20210103205233299](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103205233299.png)

- ![image-20210103205259040](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103205259040.png)

#### Bottom-up integration

特点：从最少依赖的元素开始，根据依赖结构，慢慢向上集成整个系统

![image-20210103205428436](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103205428436.png)

#### Sandwich integration

特点：结合了从上往下和从下往上集成策略的优点

![image-20210103205524996](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103205524996.png)

![image-20210103205605258](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103205605258.png)

总结：

![image-20210103205626853](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103205626853.png)

![image-20210103205639119](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103205639119.png)

### 基于调用图的集成——更关注边

- 成对集成
  - 免除桩 / 驱动模块的开发工作 ，使用实际的代码
  - 为避免大爆炸集成 ，限制在调用图的一对单元上
  - 对调用图中的每条边有一个集成测试过程
  - ![image-20210103210338059](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103210338059.png)
- 相邻集成
  - 借用拓扑学中的邻接概念
  - 在有向图中，结点邻居包括所有直接前驱结点和所有直接后继结点
  - 对应结点的桩和驱动模块集合
  - ![image-20210103210354207](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103210354207.png)

![image-20210103210406450](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103210406450.png)

![image-20210103210425234](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210103210425234.png)

### 其他集成策略

- 核心系统先行集成
- 高频集成

- 基于进度的集成

### System Testing

- 为什么系统测试是必要的？
- 一些属性只能在系统测试这一个等级才能被证实
- 我们可能把用户包含在这个等级
- 系统的环境也会被列入考虑范围之中

#### 系统测试概念

- 系统测试是测试一个完全集成的软件系统去验证它是否满足了特殊需求的过程
- 它也决定了系统是否成功地和商业程序以及环境进行集成

#### 系统测试流程

![image-20210104193426943](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104193426943.png)

### Acceptance Testing

- 接受测试是一个标准测试被执行去决定软件是否满足了在需求环节被定义地接受标准
- 最终用户或消费者能执行接受测试来验证是否接受这个产品

##### 交付测试的种类

- Alpha testing
  - $\alpha$测试时一个模拟或者真的运行测试在一个离测试团队很近的房子里
  - 这种测试帮助衡量软件是否满足了特殊需求在需求分析阶段

- Beta testing
  - $\beta$测试包括软件运行测试，该测试是在一个原理开发者团队的地方或者消费者的家里

- $\beta$测试的局限性：
  - $\beta$测试通常不是专业测试人员，问题往往停留在易用性上；
  - 环境不可控，使用不当引起的问题居多
  - 为了评价软件或获得软件而参与测试
  - 反馈信息简单，经常无法重现

#### 测试步骤（Testing life cycle）

- 制定测试计划及验收通过准则，通过客户评审
- 设计测试用例并通过评审
- 准备测试环境与数据，执行测试用例，记录测试结果
- 分析测试结果，根据验收通过准则分析测试结果，做出验收是否通过及测试评价
  - 测试项目通过；
  - 测试项目没有通过，但存在变通方法，在维护后期或下一个版本改进；
  - 测试项目没有通过，并且不存在变通方法，需要很大的修改；
  - 测试项目无法评估或者无法给出完整的评估。此时须给出原因

- 提交测试报告

## 第十三章 Regression Testing

### 为什么需要退化测试？

- 当你修改一个bug时，你会带入几个新的bug

![image-20210104201024799](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104201024799.png)

### 什么是退化测试？

- 每当软件有变化，退化测试就要被执行来保证这些变化是正确的并且它们没有相反地影响这存在的软件

- 必须执行退化测试的时间有：
  - 监测到修复行为
  - 需求变化带来的代码的相应的变化
  - 新的功能被加入到软件中

### 怎么做退化测试？

- 有多少退化测试是需要的
  - 重新测试全部？
  - 选中的测试中的一部分
  - 测试用例中因为错误失效的应该被包括为了未来的退化测试
  - 一个影响分析需要被完成来发现什么区域会被影响因为那些错误的修复。基于这些影响分析，更多的测试用例被选中来招抚这些被影响的区域

![image-20210104203825086](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104203825086.png)

- 从现有的测试用例集T中选出一个子集T'
- 在修改后的代码P'上运行T‘，用以确定P'的正确性
- 建立新的测试用例集T’‘
- 在修改后的代码P'上运行T’‘，用以确定P’的正确性
- 由T，T'，T''建立P'的测试历史和测试用例集T'''

#### 测试用例最小化

- 目的是分析依赖测试用例并且去从测试用例中删除它们目的是为了减少测试用例的大小

- 指出最小测试用例公式依赖于假设：每个需求能被一个测试用例实现。事实上，这可能不是真的

给出一个定义

![image-20210104204417060](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104204417060.png)

![image-20210104204554743](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104204554743.png)

上面有一个例子，我们使用不同的算法思想能够得出不同的测试用例集

- 第一个思想

  ![image-20210104204544204](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104204544204.png)

- 第二个思想

  ![image-20210104204618549](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104204618549.png)

- 第三个思想

  ![image-20210104204751532](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104204751532.png)

- 第四个思想

  ![image-20210104204806398](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104204806398.png)

#### The effectiveness of the minimization

![image-20210104210532238](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104210532238.png)

#### The impact of test suite minimization was measured by calculating the reduction in fault detection effectiveness as follows

![image-20210104210716939](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104210716939.png)

### Test case selection

- 减少测试用例的数量并满足测试需求

- 不同的测试标准
  - 错误检测能力
  - 代码覆盖
  - 时间损失
  - 错误侦测历史

- 把测试用例分成5类。前三类组成了存在T中的测试用例
  - 可复用的：可复用的测试用例执行程序部分保持不变和相同对P或者P'
  - 可重新测试的：它包括了被改变的代码部分，在P和P'之中
  - 废弃的：
    - 它们的输入和输出关系因为规格的变化得到改变
    - 它们不再测试它们别设计去测试的部分因为程序的改动
    - 它们是结构化的测试用例不再对程序的结构覆盖有贡献

- 剩下的两类组成了应该被收集生成退化测试用例
  - 新结构：新的结构用例测试被改变的程序结构，这些被用来组成新的部分的结构覆盖
  - 新规格：新的规格测试用例测试被改变的程序规格

#### Fault-revealing Test Cases

- 为什么是这种测试用例，是因为它能够通过不正确的输出发现程序中的错误

#### Modification-revealing Test Cases

- 这种测试用例能够发现P和P'中的输出结果是不同的

#### Modification-traversing Test Cases

- 执行被改变的区域
- 并且它的执行轨迹是不同的

![image-20210104212335570](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104212335570.png)

#### Inclusive Test Cases

![image-20210104212447299](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104212447299.png)

#### Precise Test Cases

![image-20210104212518403](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104212518403.png)

#### Safe Test Cases

![image-20210104212537239](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104212537239.png)

### Evaluation Models

几个定义：

![image-20210104212658198](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104212658198.png)

#### Effective Regression Tests can be done by selecting following test cases

- Test cases which have frequent defects
- Functionalities which are more visible to the users
- Test cases which verify core features of the product
- Test cases of Functionalities which has undergone more and recent changes
- All Integration Test Cases
- All Complex Test Cases
- Boundary value test cases
- Sample of Successful test cases
- Sample of Failure test cases

### Test case Prioritization

目标：去发现理想的测试用例顺序去测试，这样测试者能获得最大的收益

#### Average Percentage of Fault Detection(APFD) metric

- 更改的APFD值表示更快的错误发现率

- APFD的计算公式
- T是测试用例集，n是测试用例的数量，m是发现的错误
- ![image-20210104213536033](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104213536033.png)

### 什么时候进行退化测试？

- 随机执行
- 和规则保持一致
- 退化测试在什么时候结束：
  - 所有错误都被检测出来
  - 执行了所有设计好的测试用例
  - 资源用尽了
  - 项目截止了

概念辨析

#### Comparison of concepts

- Re-Testing
  - 重复测试就是再一次测试功能或者bug来确保它被修复，如果它没被修复，需要再进行检测，如果修复了，检测可以暂停

- Regression Testing
  - 退化测试就是指测试我们的软件如果我们的软件经历了一次改动，来确保新的代码不会影响之前已经可以的代码

#### Comparison of concepts

- 冒烟测试
  - 确保程序的关键功能运行正常
  - 它在任何细节功能和退化测试之前先执行
  - 它的目的是拒绝一个坏的应用，这样来节省时间
- 可用性测试
  - 结束接受一个软件后，用很小的代码或者功能上的变化，来确保bugs被修复并且没有进一步的事务被带入因为这些变化
  - 如果可用性测试失败了，那么会拒绝更深入的测试来节省时间
- BVT

#### 冒烟测试和可用性测试的比较

![image-20210104215543912](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104215543912.png)

## 第十四章 Performance testing

#### 功能测试vs性能测试

![image-20210104220145607](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104220145607.png)

### 什么是性能测试？

- 性能测试（ performance test ）就是为了获取系统性能相关指标或发现系统性能问题而进行的测试

- 一般在 真实环境、 特定负载条件下，通过 工具模拟实际软件系统的运行及其操作，同时监控性能各项指标，最后对测试结果进行分析来确定系统的性能状况

- 观察系统在一个给定的环境和场景中的性能表现是否与预期目标一致，评判系统是否存在性能缺陷，并根据测试结果识别性能瓶颈，改善系统性能的完整的过程

### 性能测试目标

- 获取系统性能某些指标数据

- 为了验证系统是否达到用户提出的性能指标
- 发现系统中存在的性能瓶颈，优化系统的性能

### 性能测试类型

- 性能验证测试
  - 验证系统是否达到事先已定义的系统性能指标、能否满足系统的性能需求

- 性能基准测试
  - 在系统标准配置下获得有关的性能指标数据，作为将来性能改进的基准线

- 性能规划测试
  - 在多种特定的环境下，获得不同的配置的系统的性能指标，从而决定在系统部署时采用什么样的软、硬件配置

### 一些常见的性能问题

- 症状
  - 启动系统、打开页面越来越慢
  - 查询数据，很长时间才显示列表
  - 网络下载速度很低，如5k/s

- 原因
  - 资源耗尽，如CPU使用率达到100%
  - 资源泄露，如内存泄漏，最终会导致资源耗尽
  - 资源瓶颈，如线程、GDI、DB连接等资源变得稀缺

### 如何评价系统的性能

![image-20210104221158568](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210104221158568.png)

### 压力测试

- 压力测试，也称为强度测试、负载测试

- 压力测试是模拟实际应用的软硬件环境及用户使用过程的系统负荷，长时间或超大负荷地运行测试软件，来测试被测系统的性能、可靠性、稳定性等。
- 在一种需要反常（如长时间的峰值）数量、频率或资源的方式下，执行可重复的负载测试，以检查程序对异常情况的抵抗能力，找出性能瓶颈或其他不稳定性问题。

### 压力测试类型

- 并发性能测试（重点）
  - 并发性能测试的过程也是一个负载测试过程，即逐渐增加并发虚拟用户数负载，直到系统出现性能瓶颈或者崩溃为止。
  - 破坏性压力测试，通过不断加载的手段，快速造成系统的崩溃，让问题尽快地暴露出来。
  - ramp-up测试 设置在多长时间内建立全部地线程。假设ramp-up period设置成T秒，全部线程数设置成N个，将每隔T/N秒建立一个线程。
- 疲劳强度测试
  - 采用系统稳定运行情况下能够支持的最大负载，持续长时间运行，以发现性能问题。
  - 渗入测试，通过长时间运行，使问题逐渐渗透出来，从而发现内存泄漏、垃圾收集（GC）或系统的其他问题，以检验系统的健壮性
  - 峰谷测试，采用高低突变加载方式进行，先加载到高水平的负载，然后急剧降低负载，稍微平息一段时间，再加载到高水平的负载，重复这样的过程，容易发现问题的蛛丝马迹，最终找到问题的根源
- 大数据量测试
  - 独立的数据量测试
    - 针对某些系统存储、传输、统计、查询等业务进行大数据量测试
  - 综合数据量测试
    - 和压力性能测试、负载性能测试、并发性能测试、疲劳性能测试相结合的综合测试方案
  - 大数据量测试：10万、100万、千万条记录
  - 大容量测试：某些字段存储10M、100M、1G等大体积数据

### 理发店模型

#### 三个假设

- 理发店中一共有3名理发师
- 每位理发师剪一个发的时间都是1小时
- 我们顾客们都是很有时间观念的人而且非常挑剔，他么对于每次光顾理发店时所能容忍的等待时间+剪发时间是3小时，而且等待时间越长，顾客的满意度越低。如果3个小时还不能剪完头发，我们的顾客会立马生气的走人

#### 场景的模拟

- ![image-20210106141104878](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210106141104878.png)

#### 理发店的性能模型

- ![image-20210106141132137](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210106141132137.png)

### 最佳/最大并发用户数

- 最佳并发用户数
  - 应当大于系统的平均负载
  - 当并发用户数持续大于该值，可能会出现部分用户请求失败

- 最大并发用户数
  - 应当大于系统的峰值负载
  - 当并发用户数大于该值，则必然会有用户请求失败

### 负载模型

- 并发用户数量+思考时间+每次请求发送的数据量+负载模式
- 并发用户数量：近似于在线用户数量-Vusers
- 思考时间：请求间隔时间
- 负载模式：一次加载，递增加载，高低突变加载，随机加载

### 性能测试的过程和实践

![image-20210106142755163](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210106142755163.png)

#### 性能测试需求和指标

- 性能测试需求：
- 用户对各项指标提出的明确需求：如果用户没有提出性能指标，则根据用户需求、测试设计人员的经验来设计各项测试指标。（需求+经验）
- 主要的性能指标
- 服务器的各项指标（CPU、内存占用率等）、后台数据库的各项指标、网络流量、响应时间......

#### 确定性能需求

- 只有具备了清楚而量化的性能指标，性能测试才能开始实施。
  - 最终用户的体验，如2-5-10s原则
  - 商业需求，如“比竞争对手的产品好”
  - 技术需求，如CPU使用率不超过70%
  - 标准要求

- 响应时间是用户的关注点
- 容量和数据吞吐量是（产品市场团队）业务处理方面的关注点
- 系统资源占用率是开发团队的技术关注点

#### 性能需求应具有可测试性

![image-20210106143650443](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210106143650443.png)

#### 如何获得可测试的性能需求

- 客户方提出
- 根据历史数据来分析
- 参考历史项目的数据
- 参考其他同行类似项目的数据
- 参考其他类似行业应用的数据
- 参考新闻或其他资料中的数据
- 80/20原则

#### 性能的具体指标

- 数据传输的吞吐量
- 数据处理效率
- 数据请求的响应时间
- 内存和CPU使用率
- 连接时间、发送时间
- 处理时间、页面下载时间
- 第一次缓冲时间
- 每秒连接数
- 每秒事务总数、每秒下载页面数
- 每秒点击次数、每秒HTTP响应数
- 每秒重试次数

#### 吞吐量

- 一次性能测试过程中网络上传输的数据量的总和
  - 如一个大型工厂，一天生产10W吨的货物，一天拉2吨的货物。运输能力是整个系统的瓶颈
  - 一个水龙头开一天一夜，流出10吨水；10个水龙头开1秒钟，流出0.1吨水。一个水龙头的吞吐量大。

- 用吞吐量来衡量一个系统的输出能力是极其不准确的，因此加单位时间--QPS/TPS

#### QPS/TPS

- 每秒钟request/事务
- 完成请求的数量/完成请求所花费的时间
- 如果10秒的时间内，系统接受到了3000个请求，返回了2000个，剩下1000报错。则：
  - QPS=2000/10=200

#### 响应时间

- 单个请求：服务响应一次请求的花费的时间。考虑完成所有请求的平均响应时间及中位数时间
- 平均响应时间：完成请求花费的总时间/完成的请求总数
  - 响应时间分别是{1，3，5，10，16}和{5，6，7，8，9}

- 中位数响应时间：意味着至少有50%的数据低于或高于这个中位数。
- TP-Top Percentile
  - TP50：50%的请求都小于某个值
  - TP90：90%的请求都小于某个值

#### 并发数

- 在某一时间点，服务器正在处理的请求数
  - 工程师经常说1秒并发2000：QPS=2000
  - 网站管理员说我们并发1000人，其实指的最大在线人数1000人
  - 运维人员说我设置的tomcat的并发数500.但是受限于CPU、OS等其他原因，并发数在实际中达不到这个数值
  - 性能测试人员说我在LR中设置了并发数3000.但是客户端受限于CPU、OS等其他原因，并不能达到此压力。从服务器的角度出发，会有排队机制以及部分请求异常溢出，并不能说服务器的并发就到了3000

- 通常，性能测试中的并发数指的是一个测试出来的结果计算值，其计算公式是QPS*平均响应时间

### 结果分析

- 捕捉被监控的数据曲线发生突变的地方——拐点

![image-20210106150518219](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210106150518219.png)

#### 响应时间分析

- 在某一点上，执行队列开始增长，因为服务器上所有的线程都已投入使用，传入的请求不再被立即处理，而是放入队列中，当线程空闲时再处理

- 当系统达到饱和点，服务器吞吐量保持稳定后，就达到了给定条件下的系统上限。但是随着服务器负载的继续增长，响应时间也随之延长，虽然吞吐量保持稳定

## 第十五章 Software bug report

#### 测试进度的S曲线法

- 进度S曲线法通过对计划中、尝试的与实际的进度三者对比来实现的，其采用的基本数据主要是测试用例或测试点的数量

![image-20210106151618510](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210106151618510.png)

#### 测试进度的NOB曲线法

![image-20210106151808266](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210106151808266.png)

### 软件缺陷的描述

#### 软件缺陷的生命周期

- 软件缺陷生命周期指的是一个软件缺陷被发现、报告到这个缺陷被修复、验证直至最后关闭的完整过程
- 缺陷生命周期是各类开发人员一起参与、协同测试的过程
- 软件缺陷一旦发现，便进入严密监控之中，直至软件缺陷生命周期终结，这样即可保证在较短的时间内高效率地关闭所有的缺陷，缩短软件测试的进程，提高软件质量，同时减少开发、测试和维护成本

- 发现-打开：测试人员找到软件缺陷并将软件缺陷提交给开发人员
- 打开-修复：开发人员再现、修复缺陷，然后提交给测试人员去验证

- 修复-关闭：测试人员验证修复过的软件，关闭已不存在的缺陷

#### 复杂的缺陷生命周期

![image-20210106152417441](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210106152417441.png)

#### 实际的缺陷生命周期

![image-20210106152445297](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210106152445297.png)

![image-20210106153528754](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210106153528754.png)

#### 严重性和优先级

- 严重性（severity）衡量缺陷对客户满意度的影响程序
  - 致命的（fatal)、严重的（critical）、一般的（major）、微小的（minor）

- 严重性级别：定义是相对的
  - 致命错误：导致系统崩溃、数据丢失、数据毁坏等；
  - 严重错误：功能或特性没有实现，主要功能部分丧失，次要功能完全丧失等；
  - 一般性错误：操作性错误、错误结果、遗漏功能等；
  - 次要错误：错误字、用户接口布局、罕见故障等。

- 优先级（Priority）：指缺陷被修复的紧急程度。
  - ![image-20210106154108660](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210106154108660.png)

- 启动系统就崩溃：严重性1，优先级1
- 界面中按钮下移：严重性3，优先级4
- 极少发生的数据毁坏：严重性1，优先级3
- 安装指南中的错别字：严重性3，优先级2

项目不同，严重性和优先级信息也不同

软件缺陷的优先级在项目期间会发生变化

#### 缺陷的其它属性

- 缺陷标识（ID）
- 缺陷类型（type），如功能、UI、性能、文档
- 缺陷产生可能性（frequency）/可再现的概率
- 缺陷来源（source）：需求、设计、编码
- 缺陷原因（cause）：数据格式、计算错误、接口参数、变量定义与引用等
- ......

#### 基本的缺陷信息

- 步骤：提供了如何重复当前缺陷的准确描述，应简明而完备、清楚而准确。这些信息对开发人员是关键的，视为修复缺陷的向导

- 期望结果：与测试用例标准或设计规格说明书或用户需求等一致，达到软件预期的功能。是验证缺陷的依据。
- 实际结果：实际执行测试的结果，不同于期望结果，从而确认缺陷的存在

#### 缺陷描述的基本要求

- 单一准确
- 可以再现
- 完整统一
- 短小简练
- 特定条件
- 补充完善
- 不做评价

#### 软件缺陷的处理和跟踪

- 确保每个被发现的缺陷都能够被解决，”解决“的意思不一定是被修正，也可能是其他处理方式
- 收集缺陷数据并根据缺陷趋势曲线识别测试处于测试过程中的哪个阶段；
- 决定测试过程是否结束，通过缺陷趋势曲线来确定测试过程是否结束是常用并且较为有效的一种方式。

#### 软件缺陷处理技巧

- 审阅。可以由测试管理员、项目管理员或其他人来进行，审阅缺陷报告的质量水平；
- 拒绝。如果审阅者决定需要对一份缺陷报告进行重大修改，应该和测试人员一起讨论，由测试人员纠正缺陷报告，然后再次提交；
- 完善。完整地描述了问题的特征并将其分离，那么审查者就会肯定这个报告
- 分配。分配给适当的开发人员，如果不知道具体开发人员，应分配给项目开发组长，由开发组长再分配给对应的开发人员；

- 验证。缺陷的修复需要得到测试人员的验证，同时还要进行回归测试，检查这个缺陷的修复是否会引入新的问题；
- 重新打开。重新打开一个缺陷，需要加注释说明、电话沟通等，否则会引起”打开-修复“多个来回，造成测试人员和开发人员不必要的矛盾
- 关闭。只有测试人员有关闭缺陷的权限，开发人员没有这个权限
- 暂缓。如果每个人都同意将确实存在的缺陷移到以后处理应该指定下一个版本号或修改的日期。一旦新的版本开始时，这些暂缓的缺陷应该重新被打开。

#### 缺陷报告

- 缺陷趋势报告，按各种状态将缺陷计数作为时间的函数显示。趋势报告可以是累计的，也可以是非累计的。
- 缺陷分布报告，允许将缺陷计数作为一个或多个缺陷参数的函数来显示，生成缺陷数量于缺陷属性的函数。如缺陷数量的缺陷状态、严重性的分布情况等。
- 缺陷年龄报告，显示缺陷处于活动状态的时间，展示一个缺陷处于某种状态的时间长短，从而了解处理这些缺陷的进度情况。

#### 缺陷趋势分析

- 监控（打开/关闭/已修正的）缺陷随时间的变化
  - 产品开发质量情况取决于累积打开/关闭曲线的趋势
  - 项目进度取决于累积打开/关闭曲线起点的时间差
  - 开发人员、测试人员的工作进度、效率也能得到反映

#### 三国会议

- 参加者：项目经理和开发组长、测试组长

- 通过Bug数据库评估每个未解决的Bug
  - 决定Bug优先级
  - 可否等到下个里程碑或版本解决
  - 谁来解决Bug triaging
- 预测项目实际进度和发布时间

#### BUG的优先排列

- 可重复性
- 可发生性
- 严重性
- 优先级=（可重复性+可发生性）*严重性

#### 必须

- 尽早定义和推广Bug管理流程
- 明确定义优先级和严重级衡量标准
- 清晰设置Bug提交必须的信息
- 周期性的会诊Bug
- 周期性的检查Bug列表

#### No

- 把全球版本的Bug和本地版本的Bug混为一谈
- 试图隐藏你的Bug
- 解决和关闭你自己的Bug
- 未经诊断发布一个补丁

#### 软件缺陷跟踪系统

- 推动团队内部的有效沟通
- 提供报表和分析
- 按照优先级排列重要bug
- 跟踪任何一个Bug的整体生命周期
- 记录任何跟Bug有关的操作
- 报告任何一个Bug的当前状态

## 第十六章 Software Testing Metrics

#### 软件度量及其过程

- 软件度量是对软件所包含的各种属性的量化表示

- 软件度量可以帮助我们深入了解软件过程和产品的衡量指标，使组织能够更好地做出决策以达成目标：
  - 用数据指标表明验收标准；
  - 监控项目进度和预见风险；
  - 分配资源时进行量化均衡；
  - 预计和控制产品的过程、成本和质量

#### 度量概念

- 测量（Measurement）：确定一个测量的行为

- 度量（Metric）：某个给定属性的度的一个定量测量

- 指标（Indicator）：具体测量的属性及其给定值，或组合值

#### 举例

- measure：文档页数，发现错误数，每个人的准备时间

- metrics：
  - preparation rate=总的准备时间/文档页数
  - fault density=错误数/文档页数

- indicator：
  - 准备程度：由preparation rate这一个metric表示
  - 查错有效性：由fault density这一个metric表示
  - 正常程度：由prep rate和fault density两个metrics组成的二维空间里去判断

#### 软件度量的内容

- 规模度量：代码行数，功能点和对象点等
- 复杂度度量：软件结构复杂度指标
- 缺陷度量：帮助确定产品缺陷变化的状态，并指示修复缺陷活动所需的工作量，分析产品缺陷分布的情况

- 工作量度量
- 进度度量
- 生产率度量：代码行数/人·月，测试用例数/人·日；
- 风险度量：”风险发生的概率“和”风险发生后所带来的损失“

- ...

#### Types of Test Metrics

- There are various types of test metrics that can be gathered in a software development project.
- Most projects need measures of quality, resources, time, and size.
  - Size measurements
  - Complexity measurements
  - Metrics unique to test

#### Size measurements

- 尺寸是一个基本的度量
- 大部分的度量被聚集标准化。这提供了一个软件项目独立分析关于尺寸
- 软件的大小能被如下几种方式计算：
  - 代码行数
    - 取决于语言和个人风格
  - 功能点
    - 独立于语言和代码行数
    - 能被很早测量
  - 括号数
    - 括号是操作员和操作数在代码工程中使用的
    - 总的操作符的数量，N1
    - 总的操作数的数量，N2
    - 不同的操作符的数量，n1
    - 不同的操作数的数量，n2
  - 软件程序尺寸N，能被如下公式测量
    - $N=N1+N2=n1log_2{n1}+n2log_2{n2}$

#### Complexity Measurements

- 复杂度测量是一个成分级别测试度量
- 组成级别的的设计度量帮助关注软件的内部特征在成分级别
- 这些度量提供了关于软件系统可靠性和稳定性的重要信息

- 环路复杂度

#### 有效软件度量的属性

- 简单的，可计算的
- 经验和直觉上有说服力
- 一致的和客观的
- 在其单位和维度的使用上是有意义的
- 编程语言独立的
- 质量反馈的有效机制

#### 软件度量的过程

- 识别目标
  - 分析出度量的工作目标和列表，并由管理者审核确认
- 定义度量过程
  - 定义其收集要素、收集过程、分析、反馈过程、IT支持体系，为具体的收集活动、分析、反馈活动和IT设备、工具开发提供指导
- 搜集数据
  - 应用IT支持工具进行数据收集工作，并按指定的方式审查和存储
- 数据分析与反馈
  - 根据数据收集结果，按照已定义的分析方法进行数据分析，完成规定格式的图表，进行反馈
- 过程改进
  - 根据度量的分析报告，管理者基于度量数据做出决策

#### 软件质量的度量

基于质量模型，带加权因子的回归公式来度量质量

$M_i=c_1*f_1+c_2*f_2+...+c_n*f_n$

$M_i$是一个软件质量因素

$f_n$是影响质量因素的度量值：软件复杂度度量、缺陷度量和规模度量...

$c_n$是加权因子

### 基于覆盖的质量评估

- 阶段错误度量

  $PI_i=W_s(S_i/E_i)+W_m(M_i/E_i)+W_i(T_i/E_i)$

- 总体质量度量

  $E_p=\sum(i*PI_i)/P_s$

#### 软件测试评估主要有两个目的

- 量化测试进程，判断测试进行的状态和进度
- 为测试或质量分析报告生成所需的量化数据，如缺陷清除率、测试覆盖率等

#### 基于需求的测试覆盖评估

- 假定$T_x$已执行的测试过程数或测试用例数，$R_{ft}$是测试需求的总数：
- $已执行的测试覆盖=T_x/R_{ft}$

- 假定$T_s$是已执行的完全成功、没有缺陷的测试过程或测试用例数：
- $成功的测试覆盖=T_s/R_{ft}$

#### 基于代码的测试覆盖评估

- 基于代码的测试覆盖评测是对被测试的程序代码语句、路径或条件的覆盖率分析。
- 基于代码的测试覆盖通过以下公式计算：
- $已执行的测试覆盖=T_c/T_{nc}$

- 其中$T_c$使用代码语句、条件分支、代码路径、数据状态判定点等已执行项目数，$T_{nc}$是代码中的项目总数

#### 缺陷评测的基线

- 为软件产品的质量设置起点，在基线的基础上再设置新的目标，作为对系统评估是否通过的标准

![image-20210106232337665](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210106232337665.png)

#### 基于缺陷清除率的估算方法

- F为描述软件规模用的功能点；D1为在软件开发过程中发现的所有缺陷数；D2为软件发布后发现的缺陷数；D为发现的总缺陷数。D=D1+D2

- 缺陷注入率（缺陷密度）=D/F
- 整体缺陷清除率=D1/D

![image-20210106232600000](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210106232600000.png)

#### 经典的种子公式

![image-20210106232953666](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210106232953666.png)

![image-20210106233007028](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210106233007028.png)

问题

- 种子bug的代表性
- 人为设置程序的bug的困难
- 缺陷相互之间可能存在相互影响或关联

#### 变异测试

- 变异测试是一种fault-based的软件测试技术
- ![image-20210106233143071](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210106233143071.png)

为了杀死这个变异，需要满足以下条件

- 测试数据必须对变异和原始程序引起不同状态覆盖。如：a=1,b=0可以达到目的。
- c的值应该传播到程序输出，并被测试检查。
- 弱变异覆盖需满足1
- 强变异覆盖需满足1、2

#### 变异测试

- 通过采用变异缺陷来模拟被测软件的真实缺陷，从而对研究人员提出的测试方法的有效性进行辅助评估
- 变异测试旨在找出有效的测试用例，发现程序中真正的错误。传统的变异测试旨在寻找这些错误的子集，能尽量充分地近似描述这些 BUG
- 变异测试则提供了基于缺陷的对测试充分性进行度量的角度，针对测试用例集的充分性进行评估和改进

##### 基于的理论

- 假设编程人员是有能力的，他们尽力去更好地开发程序，达到正确可行的结果，而不是搞破坏
- 关注在变异测试中的错误的类别
- 复杂变异体往往是由诸多简单变异体组合而成

#### 变异测试的流程

![image-20210107000239911](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107000239911.png)

#### 变异算子

- 在符合语法规则前提下，变异算子定义了从原有程序生成差别极小程序（即变异体）的转换规则

#### 变异体

- 在完成变异算子设计后，通过在原有被测程序上执行变异算子可以生成大量变异体M，在变异测试中，变异体一般被视为含缺陷程序
- 根据执行变异算子的次数，可以将变异体分为一阶变异体和高阶变异体
  - （一阶变异体）在原有程序p上执行单一变异算子并形成变异体p'，则称p‘为p的一阶变异体
  - （高阶变异体）在原有程序p上以此执行多次变异算子并形成变异体p'，则称p’为p的高阶变异体。若在p上以此执行k次变异算子并形成变异体p'，则称p‘为p的k阶变异体。

![image-20210107000941234](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107000941234.png)

![image-20210107000951539](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107000951539.png)

#### 可杀除变异体

- 若存在测试用例t，在变异体p‘和原有程序p上的执行结果不一致，则称该变异体p’相对于测试用例集T是可杀除变异体
- ![image-20210107001205803](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107001205803.png)

#### 可存活变异体

- 若不存在任何测试用例t，在变异体p‘和原有程序p上的执行结果不一致，则称该变异体p’相对于测试用例集T是可存活变异体
- 一部分可存活变异体通过设计新的测试用例可以转化成可杀除变异体，剩余的可存活变异体则可能是等价变异体

#### 等价变异体

- 若变异体p‘与原有程序p在语法上存在差异，但在语义上与p保持一致，则称p'是p的等价变异体
- ![image-20210107001441180](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107001441180.png)

#### 等价变异体检测

- 是一个不可判定问题，因此需要测试人员借助手工方式予以完成
- 等价变异体在语法层次上有微小的差别，但是在语义层次上是一致的
- 有研究人员发现，在生成的大量编译体重，等价变异体所占比例一半介于10%~40%

#### 变异体选择优化

- 变异体选择优化策略主要关注如何从生成的大量变异体中选择出典型变异体
- 随机选择法
  - 尝试从生成的大量变异体中随机选择出部分变异体
  - 首先通过执行变异算子生成大量变异体M；
  - 然后定义选择比例x；
  - 最后从变异体M中随机选择出|M|*x%的变异体，剩余未被选择的变异体则被丢弃
- 聚类选择法
  - 首先对被测程序p应用变异算子生成所有的一阶变异体；
  - 然后选择某一聚类算法根据测试用例的检测能力对所有变异体进行聚类分析，使得每个聚类内的变异体可以被相似测试用例检测到；
  - 最后从每个聚类中选择出典型变异体，而其他变异体则被丢弃
- 变异算子选择法
  - 从变异算子选择角度出发，希望在不影响变异评分的前提下，通过对变异算子进行约简来大规模缩小变异体数量，从而减小变异测试和分析开销
  - 结果表明，变异算子选择法相对于随机选择法来说并不存在明显优势
- 高阶变异体优化法
  - 高阶变异体优化法基于如下推测：
    - 执行一个K阶变异体相当于一次执行k个一阶变异体；
    - 高阶变异体中等价变异体的出现概率较小
  - 实证研究表明，采用二阶变异体可以有效减少50%的测试开销，但却不会显著降低测试的有效性

#### Metrics Unique to Test--DRE

- The common metrics unique to testing include:
  - Defect Removal Efficiency(DRE): It is the measure of defects before the delivery of software
  - DRE=(Total Number of defects found during
    development (before Delivery)) / (Total Number of defects found during development (before Delivery) + Total Number of Defects Found after Delivery)
  - DRE indicates the defect filtering ability of the testing processes

#### Metrics Unique to Test--DD

- Defect Density（DD）:It is the measure of all the found defects per size of software entity being measured

- DD=Number of Known Defects/Size(LOC,FP or Tokens)
- The relative number of defects helps the management to focus on components for additional inspection,testing,re-engineering,or replacement 

![image-20210107122033585](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107122033585.png)

- The total size of the software is 483 FP.
- calculate the DRE and DD for the project and help the management analyze data

![image-20210107122217713](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107122217713.png)

![image-20210107122242002](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107122242002.png)

#### Metrics Unique to Test--MTTF

- Mean Time to Failure(MTTF)：It is a measure of reliability. It provides the average time from one failure to the next during a test operation on a software project.
- ![image-20210107122703310](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107122703310.png)
- ![image-20210107122723982](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107122723982.png)

- ![image-20210107122735253](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107122735253.png)

#### 缺陷损耗的估算方法

- 缺陷潜伏期，通常也称为阶段潜伏期。缺陷潜伏期是一种特殊类型的缺陷分布度量
- 在实际测试工作中，发现缺陷的时间越晚，这个缺陷所带来的损害就越大，修复这个缺陷所耗费的成本就越多
- 缺陷损耗对缺陷的发现过程有效性和修复软件缺陷所耗费的成本等进行评测

![image-20210107125503270](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107125503270.png)

![image-20210107125520063](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107125520063.png)

- 缺陷损耗是使用阶段潜伏期和缺陷分布来度量缺陷消除活动的有效性的一种度量

- ![image-20210107125604324](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107125604324.png)

![image-20210107125614516](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210107125614516.png)

- 一般而言，缺陷损耗的数值越低，说明缺陷的发现过程越有效（最理想的数值应该为1）
- 用缺陷损耗来度量测试有效性的长期趋势（递减）时，它就会显示出自己的价值

#### 测试报告的具体内容

- 测试总结报告的目的是总结测试活动的结果，并根据这些结果对测试进行评价
- 这种报告是测试人员对测试工作进行总结，并识别出软件的局限性和发生失效的可能性
- 测试总结报告是测试计划的扩展，起着对测试计划“封闭回路”的作用

