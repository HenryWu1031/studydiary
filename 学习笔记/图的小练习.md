#### 第一题解释

为什么这个代码是正确的？

- 要判断这些设备是不是都是可以连接的，那我们的想法就是去遍历一遍这些设备，如果发现没有访问过的，就对这个设备进行一次DFS（深度优先搜索），在做的时候我们把我们预设的numOfConnectedComponent也随着深度优先搜索的次数而增加，那么只要它的次数不是一次，我们就可以直接return  false，因为这个说明了它至少有两个联通分量，所以肯定不是都一起连接的。

时间复杂度

- 我们在这里虽然是遍历了一遍数组，但是我们只可能去做一次对图的深度优先搜索，而基于链表表示的图的深度优先搜索的时间复杂度是O（n）（ps：这里你可以引用一个论文说明的复杂度，也可以不引，因为这个东西基本上算是一个常识），所以我们的时间复杂度就是O（n）。

#### 第二题解释

为什么这个算法是正确的？

- 第二题的目标是让我们去发现两个设备之间的最短路径有多少条，那我们很容易去想到通过BFS（宽度优先搜索）来处理这个问题，难点在于什么地方，难点在于我们以前都是搜索到目标值之后就结束我们的代码了，直接开始返回值了。但是我们这里搜索到目标设备之后，我们要继续对于我们正在遍历的这层节点进行遍历，如果再发现目标设备那么我们就把答案的值+1，这样我们可以确保我们的答案是对的。没有这个的话，我们的答案只可能是0或1。另外，因为我们对于访问有着严格的控制，所以在我们遍历的那一层的节点不会出现重复，所以我们的路径肯定都是不同的最短路径。

这个算法的时间复杂度

- 时间复杂度和上述第一题一样，我们BFS的基于链表表示的图的时间复杂度也是O（n）,并且我们的代码主要就是基于这个核心算法之上进行变更的，所以其他的部分并不会对于时间复杂度有所改变，所以我们的时间复杂度是O（n）。

#### 第三个问题

- 为什么这个算法是正确的？

第三个问题其实就是还是一个BFS（宽度优先搜索），我们从出发点开始进行BFS，然后我们把BFS过程中的节点的（有个英文的那个距离，hovs还是啥的）和它所属的子网存储在Hashmap当中，然后最后再去对于子网数组进行一个处理，主要就是把子网转换一下，然后去hashmap里面去找对应的值，然后把它给拿出来，最后return。它的正确性在于，我们的子网到初始点的距离，肯定是最小的距离，因为我们是从0-1-2-3这样一直增长上去的，我们只添加不存在于hashMap中的哈希对。

- 时间复杂度，这道题目的时间复杂度比较复杂，下面我们来一一分析，首先还是bfs的壳子，它的一个大复杂度是O（n），然后我们在里面做了一个子网的字符串转化，但是要主义的是我们一共就只有5个转化，所以可以这么说，我们的时间复杂度最多就是*5，那么还是在O（n）的范围当中，之后我们去处理子网数组的时候，要注意hashmap的get和put的时间复杂度都是1，所以我们这个时候的时间复杂度是O（Q)，综合来看呢，就是O（n+Q）的时间复杂度。