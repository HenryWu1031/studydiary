### 前情提要

作者：wwhhyy

最近很长时间没有更新了，有朋友让我麻烦看一下他要考试科目的去年的试题，出于一个计算机人的好奇心，我看了下这份试卷的难度，并做了下这份试卷，发现还是非常具有挑战性的。而且可能和国内的数据结构算法的考试题的风格不太一样。那么在这里我就把这些题目分享给大家，希望能够给大家一点小小的帮助。

#### 第一题A

##### 问题:请描述归并排序的归并过程？以及归并排序的时间复杂度，还有如何计算出归并排序的时间复杂度

归并排序的归并过程，n个元素的数组，先把它分成两部分进行归并排序，然后就是归并过程

我们使用两个指针，指向这两个子数组，然后使用一个temp数组来存储我们归并过程中的排序好的数组，比较两个指针对应的数组的值的大小，把小的那个放入temp数组，然后把对应指针推移，直到两个指针都指向子数组的最后的地方。最后再把temp数组的值放入数组当中，完成归并排序

时间复杂度$O(nlogn)$

解释，计算表达式如下

$T(n)=2T(n/2)+n$

经过数学计算得到最终的时间复杂度

#### 第一题的B

##### 问题：请描述堆的定义，并且解释如何用堆来进行升序排序以及堆排序的时间复杂度和对应的解释。

堆的定义：

a **heap** is a specialized [tree](https://en.wikipedia.org/wiki/Tree_(data_structure))-based [data structure](https://en.wikipedia.org/wiki/Data_structure) which is essentially an almost complete[[1\]](https://en.wikipedia.org/wiki/Heap_(data_structure)#cite_note-1) tree that satisfies the **heap property**: in a *max heap*, for any given [node](https://en.wikipedia.org/wiki/Node_(computer_science)) C, if P is a parent node of C, then the *key* (the *value*) of P is greater than or equal to the key of C. In a *min heap*, the key of P is less than or equal to the key of C.



如何用堆来进行升序排序

我们用无序数组构建成一个最大堆，然后把第一个位置上的元素和堆末尾的元素对换，之后让堆的大小减一，之后把堆再次构建，重复上面过程，得到一个有序的升序数列

时间复杂度$O(nlogn)$

理由：每次构建堆的时间复杂度是logn，我们要构建n次堆，所以时间复杂度如上



#### 第三题A

##### 为什么$n^2=O(n^3)$?为什么$n!=O(n^2)$

第一个问题

用我那个公式

如果存在正常数c和$n_0$,使得当$N>=n_0$时$T(N)<=cf(N)$,则记为$T(N)=O(f(N))$。

n^2 < n^3 对于$n_0$>1都成立，所以满足条件

第二个问题

不存在c和n0是的那个式子成立，所以不满足条件或者你也可以说n^2的增长速度远超n  也可以做个极限



#### 第三题的B

##### 题目：请简述均摊时间复杂度分析的重要性，并且说明删除单链表前面i个节点的均摊时间复杂度是多少？

原因：因为我们在日常分析时间复杂度的时候，不同的测试的参数会对程序的复杂度有着显著的影响，如果要精确细分每个参数下的时间复杂度会让我们的工作变得非常的复杂，但是使用均摊时间复杂度分析，我们就可以把单个情况下的时间复杂度变成类似平均时间复杂度，这样我们只需要考虑在平均情况下的时间复杂度就行了，大大降低了分析时间复杂度的复杂程度。

分析那个删除i个元素的时间复杂度，如果i=1只要1次，如果i=2，那么要两次，如果i=3，那么要三次，如果i=4，那么要4次，所以我们平均分下来是要（n+1）/2次，所以我们的时间复杂度是O(n)

#### 第四题的A

##### 简述树的先序遍历、中序遍历和后序遍历，并说明为什么宽度优先搜索可以知道图有几个联通分量？

- 第一小问
- 树的三种遍历：先序遍历，我们先遍历根节点，再遍历左子树、右子树，并以此往下按同样的模式递归下去。中序遍历，我们先遍历左子树，再遍历根节点，最后再遍历右子树，之后也是按照同样的模式递归下去。后序遍历，我们先遍历左子树、再遍历右子树、最后再遍历根节点，之后也是按照相同的模式递归下去。

第二小问

为什么可以：因为我们的BFS的遍历只能遍历一个联通分量上的节点，所以如果一次BFS之后我们还有节点没有遍历到，那么就说明这个图至少有两个联通分量，如果一次节点遍历完了所有的节点，那么这个图就只有一个联通分量



#### 第四题的B

##### 描述最小生成树的kruskal算法，并解释如何在使用算法的时候避免最小生成树出现环。以及算法的时间复杂度和解释时间复杂度

- kuskal算法：

这个算法就是把边进行排序，然后按权值从小到大选取边，把边的顶点构成集合，然后要注意避免选择的边的顶点不能够是在同一集合上的，不然就会成环，就不是最小生成树了。

- 怎么避免生成环：

使用并查集来避免生成环，如果一条边被选中了，那么就把两个顶点并入一个集合，如果发现这两个顶点本来就在一个集合中，那么就得放弃这条边

时间复杂度

$O(eloge)$

分析

e是边的数量，首先我们要把边进行排序，那么排序的时间复杂度就是O(eloge)，之后我们要进行最小生成树的边的选择，我们可以看到最多我们也只进行n-1（n是顶点数）条边的选择，并查集的操作是线性时间的，但是后面的操作所需的时间没有eloge长，所以综合起来的时间复杂度如上。



#### 第五题A

##### 题目：简述dijkstra算法如何用优先搜索树来实现，并解释这个算法的时间复杂度。

dijkstra算法：

因为dijkstra算法中需要用到优先级队列来获得当前距离起点最近的节点，这里我们可以用优先查找树来代替优先级队列来获得最小的距离起点的节点，只不过我们把从队列取数变成了在树上查找优先级最高的节点。其余内容不变。

时间复杂度是$O((m+n)logn)$

解释：

首先，我们要对整个图进行一个类似于BFS、DFS遍历的操作,这当中的时间复杂度是O（m+n)，在此基础上我们对于优先查找树的添加和删除操作都是logn的时间复杂度，所以我们最后的时间复杂度如上所示。m是边数，n是顶点数

#### 第五题B

##### 题目:详细说明floyd-warshall算法中的动态规划思想，并解释其时间复杂度

动态规划是如何使用的：

```java
for(int k=0;k<vertexes.length;k++){
    for(int i=0;i<vertexes.length;i++){
        for(int j=0;j<vertexes.lengh;j++){
            if(dist[i][k]+dist[k][j]<dist[i][j]){
                dist[i][j]=dist[i][k]+dist[k][j];
            }
        }
    }
}
```

这是动态规划的核心代码

其实这边的动态规划思想就是下面这个方程，我们假设如下状态

c(i,j,k)表示从顶点i到j经过最大的顶点序号是k的最短路径长度，

这样我们可以写出如下动态规划方程式

c(i,j,k)=min{c(i,j,k-1),c(i,k,k-1)+c(k,j,k-1)}

通过这个状态转移方程我们就可以得到上面的核心代码

其实这个动态规划的本质就是前面打的表存储了允许经过序号为k及k一下的顶点的任意两点i和j的最小路径，然后我们之后允许通过k+1,k+2，就基于上面的表继续进行更新和扩充最后得到任意两点的最短路径。

时间复杂度O($n^3$)

原因：n是顶点数量、我们看到上面的代码使用了三次循环，每一次都是n次的循环，然后循环体的操作是在常数时间可以完成的，所以最终的结果就是$O(n^3)$

#### 总结

其实这张试卷笔者也是查阅了一些资料才完成的，而且笔者认为最后的分数应该在90%左右，不知道各位观众朋友觉得难度如何呢？欢迎大家和我交流，也欢迎批评指正。希望能和大家一起变得更强！
