# 算法复习

## 00Introduction

一个介绍，没有什么特别需要去记忆的点

## 01StableMatching

- #### stable matching problem

不稳定的配对：

- 医院h偏爱学生s和它所录取的一些学生相比

- 并且学生s也跟偏爱医院h

- #### stable matching problem: input

#### input:  A set of n hospitals H and a set of n students S.

-  Each hospital h ∈ H ranks students.
-  Each student s ∈ S ranks hospitals.

![image-20210101211511562](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101211511562.png)

#### Perfect matching

定义：A matching M is a set of ordered pairs h–s with h ∈ H and s ∈ S s.t.

- 学生和医院都最多只能出现在pair中一次

怎么样才是Perfect的呢

A matching M is perfect if | M | = | H | = | S | = n.

即配对数量、医院数量和学生数量都是相同的

Example

![image-20210101211839516](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101211839516.png)

Unstable pair

- h prefers s to matched student
- s prefers h to matched hospital

![image-20210101212009280](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101212009280.png)

#### stable matching problem

定义：A stable matching is a perfect matching with no unstable pairs

稳定配对问题：给定医生表和学生表，找到一个稳定的配对

![image-20210101212337045](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101212337045.png)

问题：稳定配对一定存在吗?

答案：显然不是

Example

![image-20210101213101832](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101213101832.png)

#### Gale-Shapley algorithm

下面是算法的图（伪代码）

![image-20210101213323203](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101213323203.png)

这个算法很简单，大意就是一直循环，然后寻找h的第一个s，看s的签约状态，根据不同的签约状态得到不同的结果，继续进行循环直到所有的h和s都进行了配对

#### Proof of correctness 正确性证明

观察得到信息1：

医院根据喜好的从大到小的顺序与学生签约

观察得到信息2：

学生一旦签约后，就不会变成未配对状态，最多只是更新状态信息

##### perfect matching的证明

![image-20210101214616649](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101214616649.png)

反证法证明每个医院都会被配对

![image-20210101214731371](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101214731371.png)

大意如下：

有一个医院没有签约成功，那么肯定就会有一个学生没有签约。这说明这个学生从来没有签约过，但是这个医院肯定是尝试签约了所有学生的。那么这就产生了矛盾，所以，每个医院肯定都签约了一名学生

这样也证明了每个学生都被一个医院给签了

##### proof of correctness: stability

![image-20210101215148885](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101215148885.png)

不难理解，所以就不做特殊说明了

#### hospital optimality

前情提要：

For a given problem instance, there may be several stable matchings.

Example

![image-20210101215332940](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101215332940.png)

##### Understanding the solution

定义：Student s is a valid partner for hospital h if there exists any stable matching in which h and s are matched.

##### Hospital-optimal  assignment 

- Is it a perfect matching?
- Is it stable?

![image-20210101215647086](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101215647086.png)

![image-20210101215822767](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101215822767.png)

证明依然是使用反证法，但是逻辑有点绕

天呐 绕了好久

- 医院最优的配对代价是学生

证明的方法是和上面差不多的反证法

## 02AlgorithmAnalysis

### computational tractability

#### Word RAM

-  Each memory location and input/output cell stores a w-bit integer.
- Primitive operations: arithmetic/logic operations, read/write memory, array indexing, following a pointer, conditional branch, …

#### Running Time:

- Number of primitive operations

#### Memort

- Number of memory cells utilized

### Brute force

对于所有问题，再差都有一个暴力算法。一般这种算法都是现实中不可行的，比如说，我们上面所讲的内容中stable matching problem中我们可以列出所有的perfect matching去检查它的稳定性。

### Polynomial running time

当我们有一个程序是多项式的运行时间的时候，我们觉得这个程序是有效的

### asymptotic order of growth

#### Big O notation

![image-20210101222757576](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101222757576.png)

例子

![image-20210101222827109](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101222827109.png)

![image-20210101222918061](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101222918061.png)

说明：大O函数包括了非常多的函数，但是我们不说属于而是就是用等于号，但是这并不意味，两个大O函数相同的两个函数的时间复杂度相同

### 大O函数的几个特性

![image-20210101223233911](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101223233911.png)

函数肯定是大O函数

一个函数的常数倍数的大O函数和自己现在的大O函数相同

![image-20210101223338226](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101223338226.png)

不多描述，看上面的证明，很好理解

![image-20210101223359627](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101223359627.png)

加和乘的变换，还有就是传递性

与大O相对的还有一个时间复杂度函数的下界

![image-20210101223808107](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101223808107.png)

然后一个Big Theta notation

![image-20210101223854226](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101223854226.png)

下面是一个定理的正确性的证明：

![image-20210101224013682](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101224013682.png)

证明其实挺简单的，用到了极限的定义

![image-20210101224123776](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101224123776.png)

于此相对的还有两个定理

- ![image-20210101224148489](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101224148489.png)

- ![image-20210101224156614](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101224156614.png)

#### Big O notation with multiple variables

![image-20210101224458818](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101224458818.png)

### implementing Gale-Shapley

#### Efficient implementation

下图是更详细的伪代码图

![image-20210101224732004](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101224732004.png)

#### how to implement?

- 表示医院和学生
  - Index hospitals and students 1, …, n.

- 表示配对
  - ![image-20210101225240060](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101225240060.png)

- 表示学生的喜好
  - ![image-20210101232353832](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101232353832.png)

![image-20210101232326146](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101232326146.png)

### survey of common running times

#### Constant time

- Running time is O(1)
- Examples
  - Conditional branch
  - Arithmetic/logic operation
  -  Declare/initialize a variable
  - Follow a link in a linked list
  - Access element i in an array
  -  Compare/exchange two elements in an array

#### Linear time

- Running time is $O(n)$
- Example: ![image-20210101233307852](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101233307852.png)

- Problem: Given a sorted array of n distinct integers and an integer T, find two that sum to exactly T ?
- ![image-20210101233536483](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101233536483.png)

#### Logarithmic time

- Running time is $O(\log n)$
- Example: 二分查找
- ![image-20210101234004834](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101234004834.png)

- Problem：Given a rotated sorted array of n distinct integers and an element x, determine if x is in the array.

- 如何解决？
- ![image-20210101234513279](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101234513279.png)

- 它的第一步应该怎么做到
- ![image-20210101234552168](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101234552168.png)

#### Linearithmic time

- Running time is $O(n\log n)$

- 典型的例子：排序
- ![image-20210101234910383](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101234910383.png)

#### Quadratic time

- Running time is $O(n^2)$.

- 典型的例子：Given a list of n points in the plane (x 1 , y 1 ), …, (x n , y n ), find the pair that is closest to each other

- ![image-20210101235111890](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101235111890.png)

#### Cubic time

- Running time is $O(n^3)$
- 典型问题：三数之和（老leetcode了）

- ![image-20210101235245786](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101235245786.png)

#### Polynomial time

- Running time is $O(n^k)$

- 典型例子：![image-20210101235627830](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101235627830.png)

#### Exponential time

- Running time is $O(2^{n^k})$

- 典型例子：
- ![image-20210101235943408](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210101235943408.png)

## 03Graphs

### basic definitions and applications

#### Undirected graphs

- Notation. G=(V,E)
  - V = nodes (or vertices)
  - E = edges (or arcs) between pairs of nodes
  - Captures pairwise relationship between objects
  -  Graph size parameters: n = | V |, m = | E |

- Example: ![image-20210102000251316](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102000251316.png)

#### Graph representation: adjacency matrix

- n-by-n matrix with $A_{uv}=1\ if(u,v)\ $is an edge
  - two representation of each edge
  - space proportional to $n^2$
  - checking if $(u,v)\ $is an edge takes $\Theta(1)\ $time
  - Identifying all edges takes $\Theta(n^2)\ $time

- Example
- ![image-20210109221817300](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109221817300.png)

#### adjacency lists

- Node-indexed array of lists
- Two representations of each edge
- Space is $\Theta(m+n)$
- Checking if $(u,v)$ is an edge takes $O(degree(u))$ time
- Identifying all edges takes $\Theta(m+n)$ time

### Paths and connectivity

路径的定义：A path in an undirected graph G=(V,E) is a sequence of nodes $v_1,v_2,v_3,...,v_k$ with the property

that each consecutive pair $v_{i-1},v_i$ is joined by a different edge in E.

简单路径的定义：如果一个路径的所有节点是不同的那么这个路径是简单的

联通图的定义：一个图是联通的，当且仅当每对节点u和v都有一条路径使他们相连

#### Cycles

定义:一个环是一个路径$v_1,v_2,v_3...v_k$ 其中$v_1=v_k$ 并且 $k>=2$

定义：一个环是简单的当它所有的节点都是不同的（除了$v1$和$v_k$）

#### Trees

定义：一个无向图是一个树当且仅当它是联通的并且不包含环

理论：让G是一个有n个节点的无向图。任何两个下面的结论都能暗示第三个：

- G是联通的
- G包含一个环
- G有n-1条边

#### Rooted trees

给定一个树，选择一个根节点r并且从r开始确定各条边的方向

重要性：模型等级制度结构

例子:

![image-20210109224731169](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109224731169.png)

### Graph connectivity and graph traversal

#### Connectivity

- s-t connectivity problem. Given two nodes s and t, is there a path between s and t?
- s-t shortest path problem. Given two nodes s and t, what is the length of a shortest path between s and t?

##### Applications

- Friendster
- Maze traversal
- Kevin Bacon number
- Fewest hops in a communication network

#### Graph Search Problem

Input. A garph G=(V,E) and a starting vertex s $\in$ V

Goal.Identify the vertices of V reachable from s in G

Example: ![image-20210109225547280](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109225547280.png)

![image-20210109225559931](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109225559931.png)

#### Generic Graph Search Strategy

Input. 一个图G和一个起点s

Postcondition. 一个点是可以被起点s触及的当且仅当它被探索或被标记

第一个算法

![image-20210109225829975](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109225829975.png)

复杂度：很可能是线性时间只要合适的边能被迅速识别在每个循环的迭代中

正确性：在通用搜索算法的总结中，一个顶点v被标记为访问过当它存在一条路径从s到v

证明:[其实没怎么看懂，先存留着]

![image-20210109230408244](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109230408244.png)

另一种证明方式：【通过反证法】

![image-20210109230655586](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109230655586.png)

#### Breadth-first search

BFS intuition. Explore outward from s in all possible directions, adding nodes one "layer" at a time.

BFS algorithm

- $L_0=\{s\}$
- $L_1=$all neighbors of $L_0$
- $L_2=$all nodes that do not belong to $L_0$ or $L_1$, and that have an edge to a node in $L_1$
- $L_{i+1}=$all nodes that do not belong to an earlier layer, and that have an edge to a node in $L_i$

BFS demo

Input 一个图G在一个连接表表示中，并且一个顶点s

预条件：a vertex is reachable from if and only if it is marked as explored

![image-20210109232337209](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109232337209.png)

它和通用搜索的区别

![image-20210109232524848](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109232524848.png)

#### Running time of BFS

![image-20210109232612007](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109232612007.png)

- Line 1:$O(n)$
- Line 2:$O(1)$
- Line 3-4: $O(n)$
  - 没有节点会被探索两次
  - 每次出栈操作花费$O(1)$时间

- Line 5-6: $O(m)$
  - 每条边最多被处理两次：探索v和探索w
- Line 7-8：$O(n)$
  - 和行3-4的原因是一样的

Running time: $O(m+n)$

#### Breadth-first search tree

BFS Tree

- A Tree T rooted as s on the set of nodes reachable from s
- Add edge(u,v) to T when exploring v via u

![image-20210109233226880](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109233226880.png)

特点：在BFS搜索树中原图G的边的两个点的等级不会相差超过1

#### Depth-first search

DFS intuition

比广度优先搜索更具侵略性，经常探索最近发现的节点并且只有必要的时候才会回溯（像是在探索一个迷宫）

DFS demo

![image-20210109233501480](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109233501480.png)

同样的先决条件

![image-20210109233516138](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109233516138.png)

![image-20210109233908918](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109233908918.png)

另外一种版本的DFS

![image-20210109234544054](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109234544054.png)

#### Depth-first search tree

![image-20210109234750603](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109234750603.png)

![image-20210109234958083](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109234958083.png)

特点：【这一条目前没怎么看懂】

![image-20210109235223476](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109235223476.png)

另一个特点：

![image-20210109235614630](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109235614630.png)

![image-20210109235634784](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109235634784.png)

#### Connected component

- Find all nodes reachable from s
- ![image-20210109235755156](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109235755156.png)

- 例子
- ![image-20210109235825150](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210109235825150.png)

#### Undirected connected components

无向联通分量

下面是UCC（G）的算法

![image-20210110000035525](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110000035525.png)

### testing bipartiteness

#### Bipartite graphs

定义：一个无向图G是两个部分的如果节点被涂成蓝色或白色这样以后每条边都含有一个白点或一个蓝点 

应用：

- 稳定配对：学生是蓝 医院是白
- 调控：机器是蓝 工作是白

![image-20210110001156946](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110001156946.png)

许多图的问题会变得：

- Easier if the underlying graph is bipartite (matching).
- Tractable if the underlying graph is bipartite (independent set).

#### An obstruction to bipartiteness

结论：如果一个图可以被分成两部分，它不能包括一个长度为奇数的环

证明：长度为奇数的环不可能做到能分成两部分

![image-20210110001527679](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110001527679.png)

结论：让G是一个联通图，并且$L_0,...L_k$称为被BFS从节点s搜索出来的层数。如下两个结论之一必然成立

- 没有一层之中的两个节点存在边，并且G是两部分的
- 有一条边两个节点是在同一层的，这样G存在一个奇数环，并且G不是两部分的

第一个结论很好证明

![image-20210110002923000](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110002923000.png)

第二个结论的证明：

![image-20210110003021005](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110003021005.png)

### Connectivity in directed graphs

#### Directed graphs

![image-20210110003231741](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110003231741.png)

Ex.

- 网络图：链接点从一个网页到另一个

- 边的方向是很重要的
- 现代网页搜索引擎利用超链接结构来为网站的重要性排序

#### Graph search

- Directed reachability
  - Given a node s, find all nodes reachable from s

- Directed s~t shortest path problem
  - Given two nodes s and t, what is the length of a shortest path from s to t?

- Graph Search
  - BFS extends naturally to graphs
- Web crawler
  - Start from web page s. Find all web pages linked from s, either directly or indirectly.

#### Strong connectivity

定义：节点u和v是双重可达的如果存在u到v的路径也存在v到u的路径

定义：一个有向图是强连通的当它的所有对节点都是双重连接的

结论：一个有向图是强连通的当所有节点和它是相通的，它和所有节点是相通的。

理论：能够判断图G是否是强连通的在$O(m+n)$时间里

证明如下：

![image-20210110004233317](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110004233317.png)

#### Strong components

定义：一个强联通分量是一个最大的双重联通节点的子集

理论：

- ![image-20210110004345329](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110004345329.png)

### DAGs and topological ordering

#### Directed acyclic graphs

定义：一个有向无环图没有有向环

定义：一个有向图的拓扑排序是一个排序，这样所有的边edge($v_i,v_j$)我们拥有i<j

#### Precedence constraints

$Edge(v_i,v_j)$意味着$v_i$出现在$v_j$前面

应用：

- Course prerequisite graph: course v i must be taken before v j .
-  Compilation: module v i must be compiled before v j .
- Pipeline of computing jobs: output of job v i needed to determine input of job v j .

结论：如果G有一个拓扑顺序，那么G是一个有向无环图

通过反证法进行证明：

![image-20210110005017468](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110005017468.png)

还是挺容易就能够得到证明的

结论：如果G有一个拓扑排序顺序，那么G是一个有向无环图

问题：是不是每个有向无环图都有一个拓扑排序的顺序

问题：如果是，那么我们怎么得到它？

结论：如果G是一个有向无环图，那么G有一个节点没有任何进入的边

证明还是比较简单的

![image-20210110124555404](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110124555404.png)

结论：如果G是一个有向无环图，那么G有一个拓扑顺序

![image-20210110124721584](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110124721584.png)

#### Topological sort via DFS

![image-20210110125029336](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110125029336.png)

【理解的并不是很好，需要再去记一记】

Running time：The running time of TopoSort is$O(m+n)$ where m=\|E&#124;​ and n=\|V&#124; 

正确性：在拓扑排序的总结中，每个顶点v都被分配了一个值，并且这些值组合成了G的一个拓扑排序

![image-20210110130939452](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110130939452.png)

【多看看】

### computing strong components

定义：

![image-20210110131727152](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110131727152.png)

#### Scc meta graph

![image-20210110131938441](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110131938441.png)

#### Topological ordering of Sccs

![image-20210110132149866](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110132149866.png)

![image-20210110132338374](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110132338374.png)

搞清楚先后顺序

![image-20210110132412557](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110132412557.png)

#### Kosaraju算法

![image-20210110133040809](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110133040809.png)

![image-20210110133046992](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110133046992.png)

【重点，要仔细看】

## 04GreedyAlgorithmsPart1

### coin changing

目标：给定美元的零钱，选出一种最少的零钱组合来找零

例子: 

![image-20210110133915930](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110133915930.png)

![image-20210110133926605](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110133926605.png)

#### Cashier's algorithm

在每次迭代中，增加能使总量不超过规定数量的最大价值硬币

![image-20210110134058876](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110134058876.png)

注意：找零员算法不一定是正确的

#### Properties of any optimal solution(for U.S. coin denominations)

![image-20210110134310824](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110134310824.png)

![image-20210110134316863](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110134316863.png)

![image-20210110134326344](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110134326344.png)

![image-20210110134332102](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110134332102.png)

理论：找零员算法对于美元找零是合理的、正确的

证明：

![image-20210110134506050](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110134506050.png)

### Interval scheduling

- 工作j在$s_j$开始并在$f_j$结束
- 两个工作不发生重叠时我们说它们是和谐的
- 目标：找到最大的互相和谐的工作的子集

![image-20210110135130264](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110135130264.png)

#### interval scheduling: earliest-finish-time-first algorithm

![image-20210110135243636](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110135243636.png)

说明：能够在$O(nlog{n})$的时间中实现结束时间最先算法

- Keep track of job j* that was added last to S.
- Job j is compatible with S iff s j ≥ f j* .
- Sorting by finish times takes O(n log n) time.

#### analysis of earliest-finish-time-first algorithm

理论：最早结束时间算法是合适的

用反证法证明：

![image-20210110135541324](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110135541324.png)

### interval partitioning 

- 讲座j开始于$s_j$并且结束于$f_j$
- 目标：找到最小数量的教室让所有讲座都能够不冲突的进行

例子：

![image-20210110140142867](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110140142867.png)

#### earliest-start-time-first algorithm

![image-20210110140243091](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110140243091.png)

说明：最大开始时间优先算法能被在$O(nlog{n})$时间实现

证明：![image-20210110140535259](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110140535259.png)

观察：最早开始时间优先算法从来不会安排两个冲突的讲座在同一个教室

结论：最早开始时间优先算法是正确的

证明

-  Let d = number of classrooms that the algorithm allocates.
-  Classroom d is opened because we needed to schedule a lecture, say j, that is incompatible with a lecture in each of d – 1 other classrooms.
-  Thus, these d lectures each end after s j .
-  Since we sorted by start time, each of these incompatible lectures start no later than s j .
-  Thus, we have d lectures overlapping at time s j + ε.
-  Key observation ⇒ all schedules use ≥ d classrooms. 

### Scheduling to minimize lateness

- 单个资源每个时间只能处理一个工作
- 工作j需要$t_j$单元的处理时间并且计划在$d_j$时间完成
- 如果j从时间$S_j$开始，那么它在$f_j=s_j+t_j$结束
- 延迟：$l_j=max\{0,f_j-d_j\}$
- 目标：调度所有的工作来最小化最大延迟时间

#### Minimizing lateness: earliest deadline first

![image-20210110141920916](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110141920916.png)

例子:![image-20210110141933979](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110141933979.png)

观察到的信息1：

存在一个正确的算法是没有休息时间的

观察到的信息2：

最早结束时间优先调度没有空闲时间

#### inversions

定义：一个倒转表示一对工作i和j：i<j但是j比i先安排

观察到的信息3:

最早应该结束时间优先调度是一个独特的没有空闲时间并且没有倒转的调度

观察到的信息4：

如果一个没有空闲时间的调度有一个倒转，那么它有一个响铃的倒转

证明：

![image-20210110142604618](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110142604618.png)

【这个证明不是很难233】

![image-20210110142905776](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110142905776.png)

另一个真理的定义和证明

理论：最早截止时间优先算法在这个问题上是正确的

![image-20210110143758294](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110143758294.png)

### optimal caching

【应该是没讲过233】

## 04GreedyAlgorithmsPart2

### Dijkstra's algorithm

#### Single-pair shortest path problem

问题：![image-20210110144143268](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110144143268.png)

![image-20210110144154400](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110144154400.png)

#### Dijkstra's algorithm

贪心方法: 维持一个已经探索过的顶点集合S，这个当中有一个函数d【u】是存放s~u的最短路径

-  Initialize S ← { s }, d[s] ← 0
-  Repeatedly choose unexplored node v ∉ S which minimizes
  - ![image-20210110144612853](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110144612853.png)
  - add v to S, and set d[v] ← π(v)
- To recover path, set pred[v] ← e that achieves min

证明正确性：

![image-20210110144856536](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110144856536.png)

#### Dijkstra's algorithm: efficient implementation

![image-20210110145428873](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110145428873.png)

基本上所有的存储的数据只会减少不会增加

![image-20210110145517555](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110145517555.png)

Implementation

- 算法维持$\pi[v]$为每一个顶点v
- 优先级队列存储没有探索过的节点，使用π[⋅]作为特征
- 一旦节点u被从优先级队列中删除了，π[u]等于最短的s~u的长度

下面是算法

![image-20210110145851454](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110145851454.png)

### Minimum spanning trees

#### Cycles

定义：一个路径是一系列边它连接了一系列点

定义：一个环是一个路径没有重复的顶点和重复的边除了开始的节点和结束的节点

![image-20210110151034608](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110151034608.png)

#### Cuts

定义：一个切割是一个分类把顶点分成两个不为空的子集S和V-S

定义：一个切割的切割集是边的集合，其中一个结束点在切割之中

下面是例子：

![image-20210110151300209](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110151300209.png)

#### Cycle-cut intersection

说明：一个环和一个切割集相交于一个偶数边

例子：

![image-20210110151617735](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110151617735.png)

证明：

![image-20210110151714950](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110151714950.png)

#### spanning tree definition

定义：H（V，T）是一个图G（V，E）的子图，当且仅当H是无环并且联通的，它是生成树

![image-20210110151849424](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110151849424.png)

事实：如果H是G的生成树，那么有如下的事实

-  H is a spanning tree of G
-  H is acyclic and connected
-  H is connected and has ⎜ V ⎟ – 1 edges
-  H is acyclic and has ⎜ V ⎟ – 1 edges
-  H is minimally connected: removal of any edge disconnects it
-  H is maximally acyclic: addition of any edge creates a cycle

#### Minimum spannning tree(MST)

定义：![image-20210110152100628](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110152100628.png)

#### Fundamental cycle

![image-20210110152228533](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110152228533.png)

举例如下：

![image-20210110152246327](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110152246327.png)

我们可以发现如果$C_e$<$C_f$，那么$(V,T)$不是最小生成树

#### fundamental cutset

![image-20210110152448286](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110152448286.png)

![image-20210110152534645](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110152534645.png)

我们可以得到和上述一样的结论

#### The greedy algorithm

- Red rule
  -  Let C be a cycle with no red edges
  -  Select an uncolored edge of C of max cost and color it red

- Blue rule
  - Let D be a cutset with no blue edges
  - Select an uncolored edge in D of min cost and color it blue

- Greedy algorithm
  -  Apply the red and blue rules (nondeterministically!) until all edges are colored. The blue edges form an MST
  -  Note: can stop once n – 1 edges colored blue

#### proof of correctness

颜色不变性：There exists an MST (V, T*) containing every blue edge and no red edge

【出大问题 看不懂！！！】

【出大问题 看不懂！！！】

### Prim，Kruskal，Boruvka

#### Prim's algorithm

![image-20210110155914974](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110155914974.png)

![image-20210110160007766](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110160007766.png)

理论：Prim's algorithm算法能被实现在$O(mlog{n})$时间中

![image-20210110160200472](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110160200472.png)

#### Kruskal's algorithm

![image-20210110163210977](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110163210977.png)

证明其正确性：

![image-20210110163233260](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110163233260.png)

#### implementation

![image-20210110163316667](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110163316667.png)

#### Reverse-delete algorithm

![image-20210110163418312](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110163418312.png)

【后续继续分解，主要是对蓝色规则，红色规则的理解】





## 05DivideAndConquerPart1

### mergetsort

#### Divide-and-conquer paradigm

Divide-and-conquer

- 把问题分成几个子问题（相同种类的）
- 递归的解决这些子问题
- 联合子问题的方法来变成总的方法

Most Common usage

- 把一个大小为n的问题分成两个大小为n/2的子问题
- 递归的解决这两个子问题
- 把两个解决方案综合成一个综合的解决方案

Consequence

- Brute force:时间复杂度是$O(n^2)$
- Divide-and-conquer: 时间复杂度是$O(nlogn)$

#### mergesort

- 递归地排序左半边
- 递归地排序右半边
- 把两半边规整并让所有项是有序的

![image-20210110164304516](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110164304516.png)

#### Merging

![image-20210110164346507](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110164346507.png)

![image-20210110164356009](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110164356009.png)

#### implementation

![image-20210110164506337](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110164506337.png)

![image-20210110164515578](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110164515578.png)

证明正确性比较简单，这里就不赘述了。

####  A useful recurrence relation

定义：$T(n)=$归并排序一个长度为n的列表最大的比较次数

![image-20210110165457608](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110165457608.png)

解决办法 $T(n)\ is\ O(nlog_2{n})$

Assorted proofs. 我们描述了集中方法来解决这个递归，最初我们假设n是一个2的幂并且用=替换<=在递归中

#### recursion tree

![image-20210110170500547](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110170500547.png)

![image-20210110170526536](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110170526536.png)

#### Analysis of mergesort recurrence

![image-20210110170749115](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110170749115.png)

![image-20210110170807325](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110170807325.png)

#### Comparison tree(for 3 distinct keys a,b and c)

![image-20210110171611530](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110171611530.png)

#### Sorting lower bound

理论：任何不可抗拒的基于比较的排序必须经过$O(nlogn)$在最糟糕的情况下

证明：

- Assume array consists of n distinct values a 1 through a n .
- Worst-case number of compares = height h of pruned comparison tree
- Binary tree of height h has ≤ 2 h leaves
- n! different orderings ⇒ n! reachable leaves

![image-20210110172558843](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110172558843.png)

### counting inversions

- Divede: 把列表分成子列表A和B
- Conquer：递归地计算倒转在每个列表当中
- Combine：计算倒转在A和B之中
- 返回这三个的结果之和

![image-20210110172958788](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110172958788.png)

#### how to combine two subproblems?

![image-20210110173149553](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110173149553.png)

![image-20210110173205797](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110173205797.png)

#### divide-and-conquer algorithm implementation

![image-20210110173425303](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110173425303.png)

![image-20210110173450203](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110173450203.png)

![image-20210110173648630](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110173648630.png)

![image-20210110173705794](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110173705794.png)

### randomized quicksort

#### 3-way partitioning

目标：Given an array A and pivot element p, partition array so that:

- Elements smaller than p in left subarray L.
- Elements equal to p in middle subarray M.
- Elements larger than p in right subarray R.

挑战：![image-20210110173851536](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110173851536.png)

![image-20210110173909554](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110173909554.png)

#### Randomized quicksort

- Pick a random pivot element p ∈ A
- 3-way partition the array into L, M, and R
- Recursively sort both L and R

![image-20210110180454204](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110180454204.png)

陈述：n个不同元素的快排的期望比较次数是$O(nlogn)$

证明：

![image-20210110180713059](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110180713059.png)

#### analysis of running time

![image-20210110180816932](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110180816932.png)

![image-20210110180945125](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110180945125.png)

![image-20210110181027754](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110181027754.png)

注意：比较的次数只会减少，如果存在相同的元素

### median and selection

#### median and selection problems

![image-20210110181211450](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110181211450.png)

![image-20210110181257823](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110181257823.png)

我们可以在线性时间找到第K大的元素

这很神奇不是吗

快速选择算法

![image-20210110181342583](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110181342583.png)

#### randomized quickselect analysis

![image-20210110181650364](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110181650364.png)

![image-20210110181812569](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110181812569.png)

#### selection in worst-case linear time

![image-20210110182522884](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110182522884.png)

【不是很理解】

#### Choosing the pivot element

![image-20210110182636050](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110182636050.png)

![image-20210110182647239](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110182647239.png)

![image-20210110182802103](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110182802103.png)

![image-20210110183308485](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110183308485.png)

![image-20210110184008221](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110184008221.png)

![image-20210110184444173](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110184444173.png)

【未完待续】

## 05DivideAndConquerPart2

### master theorem

目标：![image-20210110185101529](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110185101529.png)

![image-20210110185114980](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110185114980.png)

![image-20210110185131400](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110185131400.png)

Terms

-  a ≥ 1 is the number of subproblems
-  b ≥ 2 is the factor by which the subproblem size decreases
-  f (n) ≥ 0 is the work to divide and combine subproblems

Recursion tree [assuming n is a power of b]

-  a = branching factor
-  a i = number of subproblems at level i
-  1 + log b n levels.
-  n / b i = size of subproblem at level i

![image-20210110185514463](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110185514463.png)

#### recursion tree

![image-20210110185556839](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110185556839.png)

![image-20210110195958533](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110195958533.png)

#### master theorem

![image-20210110204454886](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110204454886.png)

![image-20210110205615685](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110205615685.png)

![image-20210110205625368](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110205625368.png)

![image-20210110205632509](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110205632509.png)

#### Master thorem need not apply

- ![image-20210110205712585](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110205712585.png)
- ![image-20210110205723226](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110205723226.png)
- ![image-20210110205730809](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110205730809.png)

### Integer multiplication

#### Integer multiplication

![image-20210110210451465](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110210451465.png)

#### Divide-and-conquer multiplication

![image-20210110210525161](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110210525161.png)

我们算法的伪代码如下:

![image-20210110210555033](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110210555033.png)

但是我们发现这样没有进步，时间复杂度依然是$O(n^2)$

我们发现改变

![image-20210110210732050](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110210732050.png)

![image-20210110210741971](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110210741971.png)

所以我们发现我们的时间复杂度就变小了

#### karatsuba multiplication

![image-20210110210840600](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110210840600.png)

### matrix multiplication

#### Dot product

![image-20210110211003140](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110211003140.png)

#### Matrix multiplication

![image-20210110211038400](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110211038400.png)

#### Block matrix multiplication

![image-20210110211150252](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110211150252.png)

所以我们有简化思路

![image-20210110211236897](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110211236897.png)

![image-20210110211249868](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110211249868.png)

#### Strassen's trick

![image-20210110211413986](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110211413986.png)

#### Analysis of Strassen's algorithm

![image-20210110211505380](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110211505380.png)

![image-20210110211521023](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110211521023.png)

#### Fast matrix multiplication: theory

![image-20210110211731708](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210110211731708.png)

## 06DynamicPrograming

#### Algorithmic paradigms

- Greed
  - Process the input in some order, myopically making irrevocable decisions.

- Divide-and-conquer
  - Break up a problem into independent subproblems; solve each subproblem; combine solutions to subproblems to form solution to original problem.

- Dynamic programming
  - Break up a problem into a series of overlapping subproblems; combine solutions to smaller subproblems to form solution to large subproblem

### weighted interval scheduling

-  Job j starts at s j , finishes at f j , and has weight w j > 0
- Two jobs are compatible if they don’t overlap
- Goal: find max-weight subset of mutually compatible jobs

![image-20210102001444279](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102001444279.png)

#### Earliest-finish-time first algorithm

- 使用贪心的思想，把工作按照结束时间的递增顺序进行排列
- 然后把工作加入子集，如果它和前面已经被加入的工作不冲突的话

- 这种错法显然是错误的

![image-20210102001652300](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102001652300.png)

#### 新的算法思想：

![image-20210102001815020](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102001815020.png)

图在下面：

![image-20210102001827906](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102001827906.png)

再次有一个新的定义：

![image-20210102001912183](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102001912183.png)

然后我们的目标是：

![image-20210102002534466](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102002534466.png)

对于$OPT(j)$有两种情况：

- ![image-20210102002612891](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102002612891.png)

- ![image-20210102002622484](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102002622484.png)

所以最后我们有一个公式

![image-20210102002650348](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102002650348.png)

我们先看brute-force的实现方法

![image-20210102002841392](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102002841392.png)

可以看到这样的实现主要是靠递归来完成的

然后我们也观察到了这样的实现，运行速度是非常慢的，因为我们做了很多次重复操作

我们可以看到在一个例子下我们重复了多少重复操作

![image-20210102003119335](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102003119335.png)

左边是这个例子中的情况，右边是它的递归树

下面我们改进我们的算法：我们使用一个数组来记忆某些数据，这样就可以减少我们重复计算的时间

#### top-down dynamic programming(memoization)

![image-20210102003917711](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102003917711.png)

之后他的复杂度就会大幅度的下降

![image-20210102005316589](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102005316589.png)

前面两个是准备步骤，后面是核心的算法

所以我们看了两种算法后我们能够得到以下结论

![image-20210102010124916](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102010124916.png)

#### weighted interval scheduling: bottom-up dynamic programming

Bottom-up dynamic programming Unwind recursion

![image-20210102010758008](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102010758008.png)

- Running time The bottom-up version takes$O(n\log n)$ time

another problem

#### HOUSE COLORING PROBLEM

分析问题

![image-20210102011159351](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102011159351.png)

another problem

#### MAXIMUM SUBARRAY PROBLEM

Goal: Given an array x of n integer (positive or negative), find a contiguous subarray whose sum is maximum

解决的方式也非常简单，把式子一列，我们基本上就能把这个问题解决

![image-20210102011457902](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102011457902.png)

### segmented least squares

老师好像没讲，那我们就跳到下一节

### Knapsack problem

Goal Pack knapsack so as to maximize total value of items taken

-  There are n items: item i provides value v i > 0 and weighs w i > 0.
- Value of a subset of items = sum of values of individual items.
- Knapsack has weight limit of W.

Assumption All values and weights are integral

这个问题我们的子问题的变量有两个

![image-20210102120029749](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102120029749.png)

这个时候有两种情况，我们放物品i和不放

- ![image-20210102121740877](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102121740877.png)

- ![image-20210102121750281](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102121750281.png)

最后我们的公式如下

![image-20210102121808664](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102121808664.png)

#### Knapsack problem: bottom-up dynamic programming

这一整个图片就是一个背包问题的例子

我们可以看到问题

- ![image-20210102122644840](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102122644840.png)

和那张动态规划的状态表

- ![image-20210102122703741](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102122703741.png)

我们可以知道这个算法的时间复杂度为$O(nW)$空间复杂度为$O(nW)$

### RNA secondary structure

#### RNA. 

定义：![image-20210102123157696](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102123157696.png)

#### Secondary structure

![image-20210102123342064](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102123342064.png)

![image-20210102123350213](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102123350213.png)

举个例子

![image-20210102123430248](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102123430248.png)

除了以上的要求还有一个要求

![image-20210102123513832](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102123513832.png)

之后还有另外一个要求

![image-20210102123721617](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102123721617.png)

#### Free-energy hypothesis

![image-20210102123819275](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102123819275.png)

#### RNA secondary structure: subproblems

首次尝试

![image-20210102134855944](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102134855944.png)

那么我们的目标就是$OPT(n)$

![image-20210102134927415](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102134927415.png)

但是我们发现问题了

子问题中只有一个能够表示，另外一个不能被表示

![image-20210102135022430](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102135022430.png)

所以只能尝试另外一种子问题表示形式

![image-20210102135236422](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102135236422.png)

## 06DynamicProgramming2

### String similarity

#### Edit distance

![image-20210102140943710](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102140943710.png)

Example

![image-20210102140956048](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102140956048.png)

#### Sequence alignment

![image-20210102141251390](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102141251390.png)

按照动态规划的思想，我们来设计子问题，子问题设计如上，下面是对于问题分割的判断

![image-20210102141446819](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102141446819.png)

我们得到如下等式

![image-20210102141545551](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102141545551.png)

把它换算成从底往上的算法如下:

![image-20210102141659348](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102141659348.png)

### Hirschberg's algorithm

由上文可知，sequence-alignment的实现是空间和时间复杂度都为$O(mn)$的

下面我们要介绍的是，把这个空间复杂度降低为$O(m+n)$

- 下面是对他算法的一些小概括
- ![image-20210102142110841](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102142110841.png)

## 有点复杂，先pass一下，日后再攻克

#### longest comman subsequence

solution:  Dynamic programming

定义子问题

![image-20210102142612002](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102142612002.png)

下面是两种情况

![image-20210102142637972](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102142637972.png)

我们还是可以得到等式（Bellman equation）

![image-20210102142714030](C:\Users\why19991031\AppData\Roaming\Typora\typora-user-images\image-20210102142714030.png)